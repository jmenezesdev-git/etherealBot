{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/cdk/fesm2022/portal.mjs", "../../../../../node_modules/@angular/cdk/fesm2022/overlay.mjs", "../../../../../node_modules/@angular/cdk/fesm2022/menu.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { ElementRef, Injector, Directive, EventEmitter, Inject, Input, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n  /** Attach this portal to a host. */\n  attach(host) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n    }\n    this._attachedHost = host;\n    return host.attach(this);\n  }\n  /** Detach this portal from its host */\n  detach() {\n    let host = this._attachedHost;\n    if (host != null) {\n      this._attachedHost = null;\n      host.detach();\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwNoPortalAttachedError();\n    }\n  }\n  /** Whether this portal is attached to a host. */\n  get isAttached() {\n    return this._attachedHost != null;\n  }\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host) {\n    this._attachedHost = host;\n  }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.projectableNodes = projectableNodes;\n  }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n  constructor( /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef, /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef, /** Contextual data to be passed in to the embedded view. */\n  context, /** The injector to use for the embedded view. */\n  injector) {\n    super();\n    this.templateRef = templateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n    this.injector = injector;\n  }\n  get origin() {\n    return this.templateRef.elementRef;\n  }\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host, context = this.context) {\n    this.context = context;\n    return super.attach(host);\n  }\n  detach() {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n  constructor(element) {\n    super();\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n  constructor() {\n    /** Whether this host has already been permanently disposed. */\n    this._isDisposed = false;\n    // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n    this.attachDomPortal = null;\n  }\n  /** Whether this host has an attached portal. */\n  hasAttached() {\n    return !!this._attachedPortal;\n  }\n  /** Attaches a portal. */\n  attach(portal) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n    }\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n      // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n    } else if (this.attachDomPortal && portal instanceof DomPortal) {\n      this._attachedPortal = portal;\n      return this.attachDomPortal(portal);\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwUnknownPortalTypeError();\n    }\n  }\n  /** Detaches a previously attached portal. */\n  detach() {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n    this._invokeDisposeFn();\n  }\n  /** Permanently dispose of this portal host. */\n  dispose() {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n  /** @docs-private */\n  setDisposeFn(fn) {\n    this._disposeFn = fn;\n  }\n  _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {}\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n  /**\n   * @param outletElement Element into which the content is projected.\n   * @param _componentFactoryResolver Used to resolve the component factory.\n   *   Only required when attaching component portals.\n   * @param _appRef Reference to the application. Only used in component portals when there\n   *   is no `ViewContainerRef` available.\n   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n   *   have one. Only used for component portals.\n   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n   *   become a required parameter.\n   */\n  constructor( /** Element into which the content is projected. */\n  outletElement, _componentFactoryResolver, _appRef, _defaultInjector,\n  /**\n   * @deprecated `_document` Parameter to be made required.\n   * @breaking-change 10.0.0\n   */\n  _document) {\n    super();\n    this.outletElement = outletElement;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._defaultInjector = _defaultInjector;\n    /**\n     * Attaches a DOM portal by transferring its content into the outlet.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    this.attachDomPortal = portal => {\n      // @breaking-change 10.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n      const element = portal.element;\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      }\n      // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n      const anchorNode = this._document.createComment('dom-portal');\n      element.parentNode.insertBefore(anchorNode, element);\n      this.outletElement.appendChild(element);\n      this._attachedPortal = portal;\n      super.setDisposeFn(() => {\n        // We can't use `replaceWith` here because IE doesn't support it.\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n    this._document = _document;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal(portal) {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !resolver) {\n      throw Error('Cannot attach component portal to outlet without a ComponentFactoryResolver.');\n    }\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef;\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || undefined);\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._appRef) {\n        throw Error('Cannot attach component portal to outlet without an ApplicationRef.');\n      }\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        // Verify that the ApplicationRef has registered views before trying to detach a host view.\n        // This check also protects the `detachView` from being called on a destroyed ApplicationRef.\n        if (this._appRef.viewCount > 0) {\n          this._appRef.detachView(componentRef.hostView);\n        }\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n    this._attachedPortal = portal;\n    return componentRef;\n  }\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal(portal) {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector\n    });\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n    // Note that we want to detect changes after the nodes have been moved so that\n    // any directives inside the portal that are looking at the DOM inside a lifecycle\n    // hook won't be invoked too early.\n    viewRef.detectChanges();\n    this.setDisposeFn(() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    });\n    this._attachedPortal = portal;\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose() {\n    super.dispose();\n    this.outletElement.remove();\n  }\n  /** Gets the root HTMLElement for an instantiated component. */\n  _getComponentRootNode(componentRef) {\n    return componentRef.hostView.rootNodes[0];\n  }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {}\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nclass CdkPortal extends TemplatePortal {\n  constructor(templateRef, viewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n  static {\n    this.ɵfac = function CdkPortal_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkPortal)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkPortal,\n      selectors: [[\"\", \"cdkPortal\", \"\"]],\n      exportAs: [\"cdkPortal\"],\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkPortal, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortal]',\n      exportAs: 'cdkPortal',\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.TemplateRef\n  }, {\n    type: i0.ViewContainerRef\n  }], null);\n})();\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nclass TemplatePortalDirective extends CdkPortal {\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵTemplatePortalDirective_BaseFactory;\n      return function TemplatePortalDirective_Factory(__ngFactoryType__) {\n        return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = i0.ɵɵgetInheritedFactory(TemplatePortalDirective)))(__ngFactoryType__ || TemplatePortalDirective);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TemplatePortalDirective,\n      selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]],\n      exportAs: [\"cdkPortal\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TemplatePortalDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-portal], [portal]',\n      exportAs: 'cdkPortal',\n      providers: [{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }],\n      standalone: true\n    }]\n  }], null, null);\n})();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nclass CdkPortalOutlet extends BasePortalOutlet {\n  constructor(_componentFactoryResolver, _viewContainerRef,\n  /**\n   * @deprecated `_document` parameter to be made required.\n   * @breaking-change 9.0.0\n   */\n  _document) {\n    super();\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._viewContainerRef = _viewContainerRef;\n    /** Whether the portal component is initialized. */\n    this._isInitialized = false;\n    /** Emits when a portal is attached to the outlet. */\n    this.attached = new EventEmitter();\n    /**\n     * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    this.attachDomPortal = portal => {\n      // @breaking-change 9.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n      const element = portal.element;\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      }\n      // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n      const anchorNode = this._document.createComment('dom-portal');\n      portal.setAttachedHost(this);\n      element.parentNode.insertBefore(anchorNode, element);\n      this._getRootNode().appendChild(element);\n      this._attachedPortal = portal;\n      super.setDisposeFn(() => {\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n    this._document = _document;\n  }\n  /** Portal associated with the Portal outlet. */\n  get portal() {\n    return this._attachedPortal;\n  }\n  set portal(portal) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n    if (this.hasAttached()) {\n      super.detach();\n    }\n    if (portal) {\n      super.attach(portal);\n    }\n    this._attachedPortal = portal || null;\n  }\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef() {\n    return this._attachedRef;\n  }\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedRef = this._attachedPortal = null;\n  }\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal(portal) {\n    portal.setAttachedHost(this);\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || undefined);\n    // If we're using a view container that's different from the injected one (e.g. when the portal\n    // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n    // inside of the alternate view container.\n    if (viewContainerRef !== this._viewContainerRef) {\n      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n    }\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n    return ref;\n  }\n  /**\n   * Attach the given TemplatePortal to this PortalHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal(portal) {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector\n    });\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n    return viewRef;\n  }\n  /** Gets the root node of the portal outlet. */\n  _getRootNode() {\n    const nativeElement = this._viewContainerRef.element.nativeElement;\n    // The directive could be set on a template which will result in a comment\n    // node being the root. Use the comment's parent node if that is the case.\n    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;\n  }\n  static {\n    this.ɵfac = function CdkPortalOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkPortalOutlet)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DOCUMENT));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkPortalOutlet,\n      selectors: [[\"\", \"cdkPortalOutlet\", \"\"]],\n      inputs: {\n        portal: [0, \"cdkPortalOutlet\", \"portal\"]\n      },\n      outputs: {\n        attached: \"attached\"\n      },\n      exportAs: [\"cdkPortalOutlet\"],\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkPortalOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalOutlet]',\n      exportAs: 'cdkPortalOutlet',\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.ComponentFactoryResolver\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }], {\n    portal: [{\n      type: Input,\n      args: ['cdkPortalOutlet']\n    }],\n    attached: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass PortalHostDirective extends CdkPortalOutlet {\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵPortalHostDirective_BaseFactory;\n      return function PortalHostDirective_Factory(__ngFactoryType__) {\n        return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = i0.ɵɵgetInheritedFactory(PortalHostDirective)))(__ngFactoryType__ || PortalHostDirective);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: PortalHostDirective,\n      selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n      inputs: {\n        portal: [0, \"cdkPortalHost\", \"portal\"]\n      },\n      exportAs: [\"cdkPortalHost\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PortalHostDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalHost], [portalHost]',\n      exportAs: 'cdkPortalHost',\n      inputs: [{\n        name: 'portal',\n        alias: 'cdkPortalHost'\n      }],\n      providers: [{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }],\n      standalone: true\n    }]\n  }], null, null);\n})();\nclass PortalModule {\n  static {\n    this.ɵfac = function PortalModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PortalModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: PortalModule,\n      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PortalModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    }]\n  }], null, null);\n})();\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n  constructor(_parentInjector, _customTokens) {\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  get(token, notFoundValue) {\n    const value = this._customTokens.get(token);\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n    return this._parentInjector.get(token, notFoundValue);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };\n", "import * as i1 from '@angular/cdk/scrolling';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nexport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\nimport * as i6 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, untracked, afterRender, afterNextRender, ElementRef, EnvironmentInjector, ApplicationRef, ANIMATION_MODULE_TYPE, InjectionToken, inject, Directive, NgZone, EventEmitter, booleanAttribute, Input, Output, NgModule } from '@angular/core';\nimport { coerceCssPixelValue, coerceArray } from '@angular/cdk/coercion';\nimport * as i1$1 from '@angular/cdk/platform';\nimport { supportsScrollBehavior, _getEventTarget, _isTestEnvironment } from '@angular/cdk/platform';\nimport { filter, takeUntil, takeWhile } from 'rxjs/operators';\nimport * as i5 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { Subject, Subscription, merge } from 'rxjs';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nconst scrollBehaviorSupported = supportsScrollBehavior();\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n  constructor(_viewportRuler, document) {\n    this._viewportRuler = _viewportRuler;\n    this._previousHTMLStyles = {\n      top: '',\n      left: ''\n    };\n    this._isEnabled = false;\n    this._document = document;\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach() {}\n  /** Blocks page-level scroll while the attached overlay is open. */\n  enable() {\n    if (this._canBeEnabled()) {\n      const root = this._document.documentElement;\n      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n      // Cache the previous inline styles in case the user had set them.\n      this._previousHTMLStyles.left = root.style.left || '';\n      this._previousHTMLStyles.top = root.style.top || '';\n      // Note: we're using the `html` node, instead of the `body`, because the `body` may\n      // have the user agent margin, whereas the `html` is guaranteed not to have one.\n      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n      root.classList.add('cdk-global-scrollblock');\n      this._isEnabled = true;\n    }\n  }\n  /** Unblocks page-level scroll while the attached overlay is open. */\n  disable() {\n    if (this._isEnabled) {\n      const html = this._document.documentElement;\n      const body = this._document.body;\n      const htmlStyle = html.style;\n      const bodyStyle = body.style;\n      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n      this._isEnabled = false;\n      htmlStyle.left = this._previousHTMLStyles.left;\n      htmlStyle.top = this._previousHTMLStyles.top;\n      html.classList.remove('cdk-global-scrollblock');\n      // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n      // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n      // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n      // because it can throw off feature detections in `supportsScrollBehavior` which\n      // checks for `'scrollBehavior' in documentElement.style`.\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n      }\n      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n        bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n      }\n    }\n  }\n  _canBeEnabled() {\n    // Since the scroll strategies can't be singletons, we have to use a global CSS class\n    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n    // scrolling multiple times.\n    const html = this._document.documentElement;\n    if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n      return false;\n    }\n    const body = this._document.body;\n    const viewport = this._viewportRuler.getViewportSize();\n    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n  }\n}\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n  return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._ngZone = _ngZone;\n    this._viewportRuler = _viewportRuler;\n    this._config = _config;\n    this._scrollSubscription = null;\n    /** Detaches the overlay ref and disables the scroll strategy. */\n    this._detach = () => {\n      this.disable();\n      if (this._overlayRef.hasAttached()) {\n        this._ngZone.run(() => this._overlayRef.detach());\n      }\n    };\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /** Enables the closing of the attached overlay on scroll. */\n  enable() {\n    if (this._scrollSubscription) {\n      return;\n    }\n    const stream = this._scrollDispatcher.scrolled(0).pipe(filter(scrollable => {\n      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);\n    }));\n    if (this._config && this._config.threshold && this._config.threshold > 1) {\n      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n      this._scrollSubscription = stream.subscribe(() => {\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n          this._detach();\n        } else {\n          this._overlayRef.updatePosition();\n        }\n      });\n    } else {\n      this._scrollSubscription = stream.subscribe(this._detach);\n    }\n  }\n  /** Disables the closing the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n  detach() {\n    this.disable();\n    this._overlayRef = null;\n  }\n}\n\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n  /** Does nothing, as this scroll strategy is a no-op. */\n  enable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  disable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  attach() {}\n}\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n  return scrollContainers.some(containerBounds => {\n    const outsideAbove = element.bottom < containerBounds.top;\n    const outsideBelow = element.top > containerBounds.bottom;\n    const outsideLeft = element.right < containerBounds.left;\n    const outsideRight = element.left > containerBounds.right;\n    return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n  });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n  return scrollContainers.some(scrollContainerRect => {\n    const clippedAbove = element.top < scrollContainerRect.top;\n    const clippedBelow = element.bottom > scrollContainerRect.bottom;\n    const clippedLeft = element.left < scrollContainerRect.left;\n    const clippedRight = element.right > scrollContainerRect.right;\n    return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n  });\n}\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    this._config = _config;\n    this._scrollSubscription = null;\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /** Enables repositioning of the attached overlay on scroll. */\n  enable() {\n    if (!this._scrollSubscription) {\n      const throttle = this._config ? this._config.scrollThrottle : 0;\n      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n        this._overlayRef.updatePosition();\n        // TODO(crisbeto): make `close` on by default once all components can handle it.\n        if (this._config && this._config.autoClose) {\n          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n          const {\n            width,\n            height\n          } = this._viewportRuler.getViewportSize();\n          // TODO(crisbeto): include all ancestor scroll containers here once\n          // we have a way of exposing the trigger element to the scroll strategy.\n          const parentRects = [{\n            width,\n            height,\n            bottom: height,\n            right: width,\n            top: 0,\n            left: 0\n          }];\n          if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n            this.disable();\n            this._ngZone.run(() => this._overlayRef.detach());\n          }\n        }\n      });\n    }\n  }\n  /** Disables repositioning of the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n  detach() {\n    this.disable();\n    this._overlayRef = null;\n  }\n}\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    /** Do nothing on scroll. */\n    this.noop = () => new NoopScrollStrategy();\n    /**\n     * Close the overlay as soon as the user scrolls.\n     * @param config Configuration to be used inside the scroll strategy.\n     */\n    this.close = config => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n    /** Block scrolling. */\n    this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n    /**\n     * Update the overlay's position on scroll.\n     * @param config Configuration to be used inside the scroll strategy.\n     * Allows debouncing the reposition calls.\n     */\n    this.reposition = config => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n    this._document = document;\n  }\n  static {\n    this.ɵfac = function ScrollStrategyOptions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ScrollStrategyOptions)(i0.ɵɵinject(i1.ScrollDispatcher), i0.ɵɵinject(i1.ViewportRuler), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ScrollStrategyOptions,\n      factory: ScrollStrategyOptions.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ScrollStrategyOptions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i1.ScrollDispatcher\n  }, {\n    type: i1.ViewportRuler\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }], null);\n})();\n\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n  constructor(config) {\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    this.scrollStrategy = new NoopScrollStrategy();\n    /** Custom class to add to the overlay pane. */\n    this.panelClass = '';\n    /** Whether the overlay has a backdrop. */\n    this.hasBackdrop = false;\n    /** Custom class to add to the backdrop */\n    this.backdropClass = 'cdk-overlay-dark-backdrop';\n    /**\n     * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    this.disposeOnNavigation = false;\n    if (config) {\n      // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n      // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n      // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n      const configKeys = Object.keys(config);\n      for (const key of configKeys) {\n        if (config[key] !== undefined) {\n          // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n          // as \"I don't know *which* key this is, so the only valid value is the intersection\n          // of all the possible values.\" In this case, that happens to be `undefined`. TypeScript\n          // is not smart enough to see that the right-hand-side is actually an access of the same\n          // exact type with the same exact key, meaning that the value type must be identical.\n          // So we use `any` to work around this.\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n}\n\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n  constructor(origin, overlay, /** Offset along the X axis. */\n  offsetX, /** Offset along the Y axis. */\n  offsetY, /** Class(es) to be applied to the panel while this position is active. */\n  panelClass) {\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    this.panelClass = panelClass;\n    this.originX = origin.originX;\n    this.originY = origin.originY;\n    this.overlayX = overlay.overlayX;\n    this.overlayY = overlay.overlayY;\n  }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n  constructor( /** The position used as a result of this change. */\n  connectionPair, /** @docs-private */\n  scrollableViewProperties) {\n    this.connectionPair = connectionPair;\n    this.scrollableViewProperties = scrollableViewProperties;\n  }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n  if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n    throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` + `Expected \"top\", \"bottom\" or \"center\".`);\n  }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n  if (value !== 'start' && value !== 'end' && value !== 'center') {\n    throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` + `Expected \"start\", \"end\" or \"center\".`);\n  }\n}\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass BaseOverlayDispatcher {\n  constructor(document) {\n    /** Currently attached overlays in the order they were attached. */\n    this._attachedOverlays = [];\n    this._document = document;\n  }\n  ngOnDestroy() {\n    this.detach();\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    // Ensure that we don't get the same overlay multiple times.\n    this.remove(overlayRef);\n    this._attachedOverlays.push(overlayRef);\n  }\n  /** Remove an overlay from the list of attached overlay refs. */\n  remove(overlayRef) {\n    const index = this._attachedOverlays.indexOf(overlayRef);\n    if (index > -1) {\n      this._attachedOverlays.splice(index, 1);\n    }\n    // Remove the global listener once there are no more overlays.\n    if (this._attachedOverlays.length === 0) {\n      this.detach();\n    }\n  }\n  static {\n    this.ɵfac = function BaseOverlayDispatcher_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BaseOverlayDispatcher)(i0.ɵɵinject(DOCUMENT));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: BaseOverlayDispatcher,\n      factory: BaseOverlayDispatcher.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BaseOverlayDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }], null);\n})();\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n  constructor(document, /** @breaking-change 14.0.0 _ngZone will be required. */\n  _ngZone) {\n    super(document);\n    this._ngZone = _ngZone;\n    /** Keyboard event listener that will be attached to the body. */\n    this._keydownListener = event => {\n      const overlays = this._attachedOverlays;\n      for (let i = overlays.length - 1; i > -1; i--) {\n        // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n        // We want to target the most recent overlay, rather than trying to match where the event came\n        // from, because some components might open an overlay, but keep focus on a trigger element\n        // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n        // because we don't want overlays that don't handle keyboard events to block the ones below\n        // them that do.\n        if (overlays[i]._keydownEvents.observers.length > 0) {\n          const keydownEvents = overlays[i]._keydownEvents;\n          /** @breaking-change 14.0.0 _ngZone will be required. */\n          if (this._ngZone) {\n            this._ngZone.run(() => keydownEvents.next(event));\n          } else {\n            keydownEvents.next(event);\n          }\n          break;\n        }\n      }\n    };\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    super.add(overlayRef);\n    // Lazily start dispatcher once first overlay is added\n    if (!this._isAttached) {\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => this._document.body.addEventListener('keydown', this._keydownListener));\n      } else {\n        this._document.body.addEventListener('keydown', this._keydownListener);\n      }\n      this._isAttached = true;\n    }\n  }\n  /** Detaches the global keyboard event listener. */\n  detach() {\n    if (this._isAttached) {\n      this._document.body.removeEventListener('keydown', this._keydownListener);\n      this._isAttached = false;\n    }\n  }\n  static {\n    this.ɵfac = function OverlayKeyboardDispatcher_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || OverlayKeyboardDispatcher)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone, 8));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: OverlayKeyboardDispatcher,\n      factory: OverlayKeyboardDispatcher.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverlayKeyboardDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i0.NgZone,\n    decorators: [{\n      type: Optional\n    }]\n  }], null);\n})();\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n  constructor(document, _platform, /** @breaking-change 14.0.0 _ngZone will be required. */\n  _ngZone) {\n    super(document);\n    this._platform = _platform;\n    this._ngZone = _ngZone;\n    this._cursorStyleIsSet = false;\n    /** Store pointerdown event target to track origin of click. */\n    this._pointerDownListener = event => {\n      this._pointerDownEventTarget = _getEventTarget(event);\n    };\n    /** Click event listener that will be attached to the body propagate phase. */\n    this._clickListener = event => {\n      const target = _getEventTarget(event);\n      // In case of a click event, we want to check the origin of the click\n      // (e.g. in case where a user starts a click inside the overlay and\n      // releases the click outside of it).\n      // This is done by using the event target of the preceding pointerdown event.\n      // Every click event caused by a pointer device has a preceding pointerdown\n      // event, unless the click was programmatically triggered (e.g. in a unit test).\n      const origin = event.type === 'click' && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;\n      // Reset the stored pointerdown event target, to avoid having it interfere\n      // in subsequent events.\n      this._pointerDownEventTarget = null;\n      // We copy the array because the original may be modified asynchronously if the\n      // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n      // the for loop.\n      const overlays = this._attachedOverlays.slice();\n      // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n      // We want to target all overlays for which the click could be considered as outside click.\n      // As soon as we reach an overlay for which the click is not outside click we break off\n      // the loop.\n      for (let i = overlays.length - 1; i > -1; i--) {\n        const overlayRef = overlays[i];\n        if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n          continue;\n        }\n        // If it's a click inside the overlay, just break - we should do nothing\n        // If it's an outside click (both origin and target of the click) dispatch the mouse event,\n        // and proceed with the next overlay\n        if (containsPierceShadowDom(overlayRef.overlayElement, target) || containsPierceShadowDom(overlayRef.overlayElement, origin)) {\n          break;\n        }\n        const outsidePointerEvents = overlayRef._outsidePointerEvents;\n        /** @breaking-change 14.0.0 _ngZone will be required. */\n        if (this._ngZone) {\n          this._ngZone.run(() => outsidePointerEvents.next(event));\n        } else {\n          outsidePointerEvents.next(event);\n        }\n      }\n    };\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    super.add(overlayRef);\n    // Safari on iOS does not generate click events for non-interactive\n    // elements. However, we want to receive a click for any element outside\n    // the overlay. We can force a \"clickable\" state by setting\n    // `cursor: pointer` on the document body. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n    // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n    if (!this._isAttached) {\n      const body = this._document.body;\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));\n      } else {\n        this._addEventListeners(body);\n      }\n      // click event is not fired on iOS. To make element \"clickable\" we are\n      // setting the cursor to pointer\n      if (this._platform.IOS && !this._cursorStyleIsSet) {\n        this._cursorOriginalValue = body.style.cursor;\n        body.style.cursor = 'pointer';\n        this._cursorStyleIsSet = true;\n      }\n      this._isAttached = true;\n    }\n  }\n  /** Detaches the global keyboard event listener. */\n  detach() {\n    if (this._isAttached) {\n      const body = this._document.body;\n      body.removeEventListener('pointerdown', this._pointerDownListener, true);\n      body.removeEventListener('click', this._clickListener, true);\n      body.removeEventListener('auxclick', this._clickListener, true);\n      body.removeEventListener('contextmenu', this._clickListener, true);\n      if (this._platform.IOS && this._cursorStyleIsSet) {\n        body.style.cursor = this._cursorOriginalValue;\n        this._cursorStyleIsSet = false;\n      }\n      this._isAttached = false;\n    }\n  }\n  _addEventListeners(body) {\n    body.addEventListener('pointerdown', this._pointerDownListener, true);\n    body.addEventListener('click', this._clickListener, true);\n    body.addEventListener('auxclick', this._clickListener, true);\n    body.addEventListener('contextmenu', this._clickListener, true);\n  }\n  static {\n    this.ɵfac = function OverlayOutsideClickDispatcher_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || OverlayOutsideClickDispatcher)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1$1.Platform), i0.ɵɵinject(i0.NgZone, 8));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: OverlayOutsideClickDispatcher,\n      factory: OverlayOutsideClickDispatcher.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverlayOutsideClickDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }, {\n    type: i0.NgZone,\n    decorators: [{\n      type: Optional\n    }]\n  }], null);\n})();\n/** Version of `Element.contains` that transcends shadow DOM boundaries. */\nfunction containsPierceShadowDom(parent, child) {\n  const supportsShadowRoot = typeof ShadowRoot !== 'undefined' && ShadowRoot;\n  let current = child;\n  while (current) {\n    if (current === parent) {\n      return true;\n    }\n    current = supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;\n  }\n  return false;\n}\n\n/** Container inside which all overlays will render. */\nclass OverlayContainer {\n  constructor(document, _platform) {\n    this._platform = _platform;\n    this._document = document;\n  }\n  ngOnDestroy() {\n    this._containerElement?.remove();\n  }\n  /**\n   * This method returns the overlay container element. It will lazily\n   * create the element the first time it is called to facilitate using\n   * the container in non-browser environments.\n   * @returns the container element\n   */\n  getContainerElement() {\n    if (!this._containerElement) {\n      this._createContainer();\n    }\n    return this._containerElement;\n  }\n  /**\n   * Create the overlay container element, which is simply a div\n   * with the 'cdk-overlay-container' class on the document body.\n   */\n  _createContainer() {\n    const containerClass = 'cdk-overlay-container';\n    // TODO(crisbeto): remove the testing check once we have an overlay testing\n    // module or Angular starts tearing down the testing `NgModule`. See:\n    // https://github.com/angular/angular/issues/18831\n    if (this._platform.isBrowser || _isTestEnvironment()) {\n      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` + `.${containerClass}[platform=\"test\"]`);\n      // Remove any old containers from the opposite platform.\n      // This can happen when transitioning from the server to the client.\n      for (let i = 0; i < oppositePlatformContainers.length; i++) {\n        oppositePlatformContainers[i].remove();\n      }\n    }\n    const container = this._document.createElement('div');\n    container.classList.add(containerClass);\n    // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n    // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n    // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n    // To mitigate the problem we made it so that only containers from a different platform are\n    // cleared, but the side-effect was that people started depending on the overly-aggressive\n    // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n    // module which does the cleanup, we try to detect that we're in a test environment and we\n    // always clear the container. See #17006.\n    // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n    if (_isTestEnvironment()) {\n      container.setAttribute('platform', 'test');\n    } else if (!this._platform.isBrowser) {\n      container.setAttribute('platform', 'server');\n    }\n    this._document.body.appendChild(container);\n    this._containerElement = container;\n  }\n  static {\n    this.ɵfac = function OverlayContainer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || OverlayContainer)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1$1.Platform));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: OverlayContainer,\n      factory: OverlayContainer.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverlayContainer, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }], null);\n})();\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector) {\n    this._portalOutlet = _portalOutlet;\n    this._host = _host;\n    this._pane = _pane;\n    this._config = _config;\n    this._ngZone = _ngZone;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._document = _document;\n    this._location = _location;\n    this._outsideClickDispatcher = _outsideClickDispatcher;\n    this._animationsDisabled = _animationsDisabled;\n    this._injector = _injector;\n    this._backdropElement = null;\n    this._backdropClick = new Subject();\n    this._attachments = new Subject();\n    this._detachments = new Subject();\n    this._locationChanges = Subscription.EMPTY;\n    this._backdropClickHandler = event => this._backdropClick.next(event);\n    this._backdropTransitionendHandler = event => {\n      this._disposeBackdrop(event.target);\n    };\n    /** Stream of keydown events dispatched to this overlay. */\n    this._keydownEvents = new Subject();\n    /** Stream of mouse outside events dispatched to this overlay. */\n    this._outsidePointerEvents = new Subject();\n    this._renders = new Subject();\n    if (_config.scrollStrategy) {\n      this._scrollStrategy = _config.scrollStrategy;\n      this._scrollStrategy.attach(this);\n    }\n    this._positionStrategy = _config.positionStrategy;\n    // Users could open the overlay from an `effect`, in which case we need to\n    // run the `afterRender` as `untracked`. We don't recommend that users do\n    // this, but we also don't want to break users who are doing it.\n    this._afterRenderRef = untracked(() => afterRender(() => {\n      this._renders.next();\n    }, {\n      injector: this._injector\n    }));\n  }\n  /** The overlay's HTML element */\n  get overlayElement() {\n    return this._pane;\n  }\n  /** The overlay's backdrop HTML element. */\n  get backdropElement() {\n    return this._backdropElement;\n  }\n  /**\n   * Wrapper around the panel element. Can be used for advanced\n   * positioning where a wrapper with specific styling is\n   * required around the overlay pane.\n   */\n  get hostElement() {\n    return this._host;\n  }\n  /**\n   * Attaches content, given via a Portal, to the overlay.\n   * If the overlay is configured to have a backdrop, it will be created.\n   *\n   * @param portal Portal instance to which to attach the overlay.\n   * @returns The portal attachment result.\n   */\n  attach(portal) {\n    // Insert the host into the DOM before attaching the portal, otherwise\n    // the animations module will skip animations on repeat attachments.\n    if (!this._host.parentElement && this._previousHostParent) {\n      this._previousHostParent.appendChild(this._host);\n    }\n    const attachResult = this._portalOutlet.attach(portal);\n    if (this._positionStrategy) {\n      this._positionStrategy.attach(this);\n    }\n    this._updateStackingOrder();\n    this._updateElementSize();\n    this._updateElementDirection();\n    if (this._scrollStrategy) {\n      this._scrollStrategy.enable();\n    }\n    // Update the position once the overlay is fully rendered before attempting to position it,\n    // as the position may depend on the size of the rendered content.\n    afterNextRender(() => {\n      // The overlay could've been detached before the callback executed.\n      if (this.hasAttached()) {\n        this.updatePosition();\n      }\n    }, {\n      injector: this._injector\n    });\n    // Enable pointer events for the overlay pane element.\n    this._togglePointerEvents(true);\n    if (this._config.hasBackdrop) {\n      this._attachBackdrop();\n    }\n    if (this._config.panelClass) {\n      this._toggleClasses(this._pane, this._config.panelClass, true);\n    }\n    // Only emit the `attachments` event once all other setup is done.\n    this._attachments.next();\n    // Track this overlay by the keyboard dispatcher\n    this._keyboardDispatcher.add(this);\n    if (this._config.disposeOnNavigation) {\n      this._locationChanges = this._location.subscribe(() => this.dispose());\n    }\n    this._outsideClickDispatcher.add(this);\n    // TODO(crisbeto): the null check is here, because the portal outlet returns `any`.\n    // We should be guaranteed for the result to be `ComponentRef | EmbeddedViewRef`, but\n    // `instanceof EmbeddedViewRef` doesn't appear to work at the moment.\n    if (typeof attachResult?.onDestroy === 'function') {\n      // In most cases we control the portal and we know when it is being detached so that\n      // we can finish the disposal process. The exception is if the user passes in a custom\n      // `ViewContainerRef` that isn't destroyed through the overlay API. Note that we use\n      // `detach` here instead of `dispose`, because we don't know if the user intends to\n      // reattach the overlay at a later point. It also has the advantage of waiting for animations.\n      attachResult.onDestroy(() => {\n        if (this.hasAttached()) {\n          // We have to delay the `detach` call, because detaching immediately prevents\n          // other destroy hooks from running. This is likely a framework bug similar to\n          // https://github.com/angular/angular/issues/46119\n          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));\n        }\n      });\n    }\n    return attachResult;\n  }\n  /**\n   * Detaches an overlay from a portal.\n   * @returns The portal detachment result.\n   */\n  detach() {\n    if (!this.hasAttached()) {\n      return;\n    }\n    this.detachBackdrop();\n    // When the overlay is detached, the pane element should disable pointer events.\n    // This is necessary because otherwise the pane element will cover the page and disable\n    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n    this._togglePointerEvents(false);\n    if (this._positionStrategy && this._positionStrategy.detach) {\n      this._positionStrategy.detach();\n    }\n    if (this._scrollStrategy) {\n      this._scrollStrategy.disable();\n    }\n    const detachmentResult = this._portalOutlet.detach();\n    // Only emit after everything is detached.\n    this._detachments.next();\n    // Remove this overlay from keyboard dispatcher tracking.\n    this._keyboardDispatcher.remove(this);\n    // Keeping the host element in the DOM can cause scroll jank, because it still gets\n    // rendered, even though it's transparent and unclickable which is why we remove it.\n    this._detachContentWhenEmpty();\n    this._locationChanges.unsubscribe();\n    this._outsideClickDispatcher.remove(this);\n    return detachmentResult;\n  }\n  /** Cleans up the overlay from the DOM. */\n  dispose() {\n    const isAttached = this.hasAttached();\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n    this._disposeScrollStrategy();\n    this._disposeBackdrop(this._backdropElement);\n    this._locationChanges.unsubscribe();\n    this._keyboardDispatcher.remove(this);\n    this._portalOutlet.dispose();\n    this._attachments.complete();\n    this._backdropClick.complete();\n    this._keydownEvents.complete();\n    this._outsidePointerEvents.complete();\n    this._outsideClickDispatcher.remove(this);\n    this._host?.remove();\n    this._previousHostParent = this._pane = this._host = null;\n    if (isAttached) {\n      this._detachments.next();\n    }\n    this._detachments.complete();\n    this._afterRenderRef.destroy();\n    this._renders.complete();\n  }\n  /** Whether the overlay has attached content. */\n  hasAttached() {\n    return this._portalOutlet.hasAttached();\n  }\n  /** Gets an observable that emits when the backdrop has been clicked. */\n  backdropClick() {\n    return this._backdropClick;\n  }\n  /** Gets an observable that emits when the overlay has been attached. */\n  attachments() {\n    return this._attachments;\n  }\n  /** Gets an observable that emits when the overlay has been detached. */\n  detachments() {\n    return this._detachments;\n  }\n  /** Gets an observable of keydown events targeted to this overlay. */\n  keydownEvents() {\n    return this._keydownEvents;\n  }\n  /** Gets an observable of pointer events targeted outside this overlay. */\n  outsidePointerEvents() {\n    return this._outsidePointerEvents;\n  }\n  /** Gets the current overlay configuration, which is immutable. */\n  getConfig() {\n    return this._config;\n  }\n  /** Updates the position of the overlay based on the position strategy. */\n  updatePosition() {\n    if (this._positionStrategy) {\n      this._positionStrategy.apply();\n    }\n  }\n  /** Switches to a new position strategy and updates the overlay position. */\n  updatePositionStrategy(strategy) {\n    if (strategy === this._positionStrategy) {\n      return;\n    }\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n    this._positionStrategy = strategy;\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      this.updatePosition();\n    }\n  }\n  /** Update the size properties of the overlay. */\n  updateSize(sizeConfig) {\n    this._config = {\n      ...this._config,\n      ...sizeConfig\n    };\n    this._updateElementSize();\n  }\n  /** Sets the LTR/RTL direction for the overlay. */\n  setDirection(dir) {\n    this._config = {\n      ...this._config,\n      direction: dir\n    };\n    this._updateElementDirection();\n  }\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes) {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, true);\n    }\n  }\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes) {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, false);\n    }\n  }\n  /**\n   * Returns the layout direction of the overlay panel.\n   */\n  getDirection() {\n    const direction = this._config.direction;\n    if (!direction) {\n      return 'ltr';\n    }\n    return typeof direction === 'string' ? direction : direction.value;\n  }\n  /** Switches to a new scroll strategy. */\n  updateScrollStrategy(strategy) {\n    if (strategy === this._scrollStrategy) {\n      return;\n    }\n    this._disposeScrollStrategy();\n    this._scrollStrategy = strategy;\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      strategy.enable();\n    }\n  }\n  /** Updates the text direction of the overlay panel. */\n  _updateElementDirection() {\n    this._host.setAttribute('dir', this.getDirection());\n  }\n  /** Updates the size of the overlay element based on the overlay config. */\n  _updateElementSize() {\n    if (!this._pane) {\n      return;\n    }\n    const style = this._pane.style;\n    style.width = coerceCssPixelValue(this._config.width);\n    style.height = coerceCssPixelValue(this._config.height);\n    style.minWidth = coerceCssPixelValue(this._config.minWidth);\n    style.minHeight = coerceCssPixelValue(this._config.minHeight);\n    style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n    style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n  }\n  /** Toggles the pointer events for the overlay pane element. */\n  _togglePointerEvents(enablePointer) {\n    this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n  }\n  /** Attaches a backdrop for this overlay. */\n  _attachBackdrop() {\n    const showingClass = 'cdk-overlay-backdrop-showing';\n    this._backdropElement = this._document.createElement('div');\n    this._backdropElement.classList.add('cdk-overlay-backdrop');\n    if (this._animationsDisabled) {\n      this._backdropElement.classList.add('cdk-overlay-backdrop-noop-animation');\n    }\n    if (this._config.backdropClass) {\n      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n    }\n    // Insert the backdrop before the pane in the DOM order,\n    // in order to handle stacked overlays properly.\n    this._host.parentElement.insertBefore(this._backdropElement, this._host);\n    // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n    // action desired when such a click occurs (usually closing the overlay).\n    this._backdropElement.addEventListener('click', this._backdropClickHandler);\n    // Add class to fade-in the backdrop after one frame.\n    if (!this._animationsDisabled && typeof requestAnimationFrame !== 'undefined') {\n      this._ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(() => {\n          if (this._backdropElement) {\n            this._backdropElement.classList.add(showingClass);\n          }\n        });\n      });\n    } else {\n      this._backdropElement.classList.add(showingClass);\n    }\n  }\n  /**\n   * Updates the stacking order of the element, moving it to the top if necessary.\n   * This is required in cases where one overlay was detached, while another one,\n   * that should be behind it, was destroyed. The next time both of them are opened,\n   * the stacking will be wrong, because the detached element's pane will still be\n   * in its original DOM position.\n   */\n  _updateStackingOrder() {\n    if (this._host.nextSibling) {\n      this._host.parentNode.appendChild(this._host);\n    }\n  }\n  /** Detaches the backdrop (if any) associated with the overlay. */\n  detachBackdrop() {\n    const backdropToDetach = this._backdropElement;\n    if (!backdropToDetach) {\n      return;\n    }\n    if (this._animationsDisabled) {\n      this._disposeBackdrop(backdropToDetach);\n      return;\n    }\n    backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n    this._ngZone.runOutsideAngular(() => {\n      backdropToDetach.addEventListener('transitionend', this._backdropTransitionendHandler);\n    });\n    // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n    // In this case we make it unclickable and we try to remove it after a delay.\n    backdropToDetach.style.pointerEvents = 'none';\n    // Run this outside the Angular zone because there's nothing that Angular cares about.\n    // If it were to run inside the Angular zone, every test that used Overlay would have to be\n    // either async or fakeAsync.\n    this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {\n      this._disposeBackdrop(backdropToDetach);\n    }, 500));\n  }\n  /** Toggles a single CSS class or an array of classes on an element. */\n  _toggleClasses(element, cssClasses, isAdd) {\n    const classes = coerceArray(cssClasses || []).filter(c => !!c);\n    if (classes.length) {\n      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);\n    }\n  }\n  /** Detaches the overlay content next time the zone stabilizes. */\n  _detachContentWhenEmpty() {\n    // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n    // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n    // be patched to run inside the zone, which will throw us into an infinite loop.\n    this._ngZone.runOutsideAngular(() => {\n      // We can't remove the host here immediately, because the overlay pane's content\n      // might still be animating. This stream helps us avoid interrupting the animation\n      // by waiting for the pane to become empty.\n      const subscription = this._renders.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {\n        // Needs a couple of checks for the pane and host, because\n        // they may have been removed by the time the zone stabilizes.\n        if (!this._pane || !this._host || this._pane.children.length === 0) {\n          if (this._pane && this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, false);\n          }\n          if (this._host && this._host.parentElement) {\n            this._previousHostParent = this._host.parentElement;\n            this._host.remove();\n          }\n          subscription.unsubscribe();\n        }\n      });\n    });\n  }\n  /** Disposes of a scroll strategy. */\n  _disposeScrollStrategy() {\n    const scrollStrategy = this._scrollStrategy;\n    if (scrollStrategy) {\n      scrollStrategy.disable();\n      if (scrollStrategy.detach) {\n        scrollStrategy.detach();\n      }\n    }\n  }\n  /** Removes a backdrop element from the DOM. */\n  _disposeBackdrop(backdrop) {\n    if (backdrop) {\n      backdrop.removeEventListener('click', this._backdropClickHandler);\n      backdrop.removeEventListener('transitionend', this._backdropTransitionendHandler);\n      backdrop.remove();\n      // It is possible that a new portal has been attached to this overlay since we started\n      // removing the backdrop. If that is the case, only clear the backdrop reference if it\n      // is still the same instance that we started to remove.\n      if (this._backdropElement === backdrop) {\n        this._backdropElement = null;\n      }\n    }\n    if (this._backdropTimeout) {\n      clearTimeout(this._backdropTimeout);\n      this._backdropTimeout = undefined;\n    }\n  }\n}\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n  /** Ordered list of preferred positions, from most to least desirable. */\n  get positions() {\n    return this._preferredPositions;\n  }\n  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n    this._platform = _platform;\n    this._overlayContainer = _overlayContainer;\n    /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n    this._lastBoundingBoxSize = {\n      width: 0,\n      height: 0\n    };\n    /** Whether the overlay was pushed in a previous positioning. */\n    this._isPushed = false;\n    /** Whether the overlay can be pushed on-screen on the initial open. */\n    this._canPush = true;\n    /** Whether the overlay can grow via flexible width/height after the initial open. */\n    this._growAfterOpen = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    this._hasFlexibleDimensions = true;\n    /** Whether the overlay position is locked. */\n    this._positionLocked = false;\n    /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n    this._viewportMargin = 0;\n    /** The Scrollable containers used to check scrollable view properties on position change. */\n    this._scrollables = [];\n    /** Ordered list of preferred positions, from most to least desirable. */\n    this._preferredPositions = [];\n    /** Subject that emits whenever the position changes. */\n    this._positionChanges = new Subject();\n    /** Subscription to viewport size changes. */\n    this._resizeSubscription = Subscription.EMPTY;\n    /** Default offset for the overlay along the x axis. */\n    this._offsetX = 0;\n    /** Default offset for the overlay along the y axis. */\n    this._offsetY = 0;\n    /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n    this._appliedPanelClasses = [];\n    /** Observable sequence of position changes. */\n    this.positionChanges = this._positionChanges;\n    this.setOrigin(connectedTo);\n  }\n  /** Attaches this position strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('This position strategy is already attached to an overlay');\n    }\n    this._validatePositions();\n    overlayRef.hostElement.classList.add(boundingBoxClass);\n    this._overlayRef = overlayRef;\n    this._boundingBox = overlayRef.hostElement;\n    this._pane = overlayRef.overlayElement;\n    this._isDisposed = false;\n    this._isInitialRender = true;\n    this._lastPosition = null;\n    this._resizeSubscription.unsubscribe();\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n      // When the window is resized, we want to trigger the next reposition as if it\n      // was an initial render, in order for the strategy to pick a new optimal position,\n      // otherwise position locking will cause it to stay at the old one.\n      this._isInitialRender = true;\n      this.apply();\n    });\n  }\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin best fits on-screen.\n   *\n   * The selection of a position goes as follows:\n   *  - If any positions fit completely within the viewport as-is,\n   *      choose the first position that does so.\n   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n   *      choose the position with the greatest available size modified by the positions' weight.\n   *  - If pushing is enabled, take the position that went off-screen the least and push it\n   *      on-screen.\n   *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n   * @docs-private\n   */\n  apply() {\n    // We shouldn't do anything if the strategy was disposed or we're on the server.\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n    // If the position has been applied already (e.g. when the overlay was opened) and the\n    // consumer opted into locking in the position, re-use the old position, in order to\n    // prevent the overlay from jumping around.\n    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n      this.reapplyLastPosition();\n      return;\n    }\n    this._clearPanelClasses();\n    this._resetOverlayElementStyles();\n    this._resetBoundingBoxStyles();\n    // We need the bounding rects for the origin, the overlay and the container to determine how to position\n    // the overlay relative to the origin.\n    // We use the viewport rect to determine whether a position would go off-screen.\n    this._viewportRect = this._getNarrowedViewportRect();\n    this._originRect = this._getOriginRect();\n    this._overlayRect = this._pane.getBoundingClientRect();\n    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n    const originRect = this._originRect;\n    const overlayRect = this._overlayRect;\n    const viewportRect = this._viewportRect;\n    const containerRect = this._containerRect;\n    // Positions where the overlay will fit with flexible dimensions.\n    const flexibleFits = [];\n    // Fallback if none of the preferred positions fit within the viewport.\n    let fallback;\n    // Go through each of the preferred positions looking for a good fit.\n    // If a good fit is found, it will be applied immediately.\n    for (let pos of this._preferredPositions) {\n      // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n      let originPoint = this._getOriginPoint(originRect, containerRect, pos);\n      // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n      // overlay in this position. We use the top-left corner for calculations and later translate\n      // this into an appropriate (top, left, bottom, right) style.\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n      // Calculate how well the overlay would fit into the viewport with this point.\n      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n      // If the overlay, without any further work, fits into the viewport, use this position.\n      if (overlayFit.isCompletelyWithinViewport) {\n        this._isPushed = false;\n        this._applyPosition(pos, originPoint);\n        return;\n      }\n      // If the overlay has flexible dimensions, we can use this position\n      // so long as there's enough space for the minimum dimensions.\n      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n        // Save positions where the overlay will fit with flexible dimensions. We will use these\n        // if none of the positions fit *without* flexible dimensions.\n        flexibleFits.push({\n          position: pos,\n          origin: originPoint,\n          overlayRect,\n          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n        });\n        continue;\n      }\n      // If the current preferred position does not fit on the screen, remember the position\n      // if it has more visible area on-screen than we've seen and move onto the next preferred\n      // position.\n      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n        fallback = {\n          overlayFit,\n          overlayPoint,\n          originPoint,\n          position: pos,\n          overlayRect\n        };\n      }\n    }\n    // If there are any positions where the overlay would fit with flexible dimensions, choose the\n    // one that has the greatest area available modified by the position's weight\n    if (flexibleFits.length) {\n      let bestFit = null;\n      let bestScore = -1;\n      for (const fit of flexibleFits) {\n        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n        if (score > bestScore) {\n          bestScore = score;\n          bestFit = fit;\n        }\n      }\n      this._isPushed = false;\n      this._applyPosition(bestFit.position, bestFit.origin);\n      return;\n    }\n    // When none of the preferred positions fit within the viewport, take the position\n    // that went off-screen the least and attempt to push it on-screen.\n    if (this._canPush) {\n      // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n      this._isPushed = true;\n      this._applyPosition(fallback.position, fallback.originPoint);\n      return;\n    }\n    // All options for getting the overlay within the viewport have been exhausted, so go with the\n    // position that went off-screen the least.\n    this._applyPosition(fallback.position, fallback.originPoint);\n  }\n  detach() {\n    this._clearPanelClasses();\n    this._lastPosition = null;\n    this._previousPushAmount = null;\n    this._resizeSubscription.unsubscribe();\n  }\n  /** Cleanup after the element gets destroyed. */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    // We can't use `_resetBoundingBoxStyles` here, because it resets\n    // some properties to zero, rather than removing them.\n    if (this._boundingBox) {\n      extendStyles(this._boundingBox.style, {\n        top: '',\n        left: '',\n        right: '',\n        bottom: '',\n        height: '',\n        width: '',\n        alignItems: '',\n        justifyContent: ''\n      });\n    }\n    if (this._pane) {\n      this._resetOverlayElementStyles();\n    }\n    if (this._overlayRef) {\n      this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n    }\n    this.detach();\n    this._positionChanges.complete();\n    this._overlayRef = this._boundingBox = null;\n    this._isDisposed = true;\n  }\n  /**\n   * This re-aligns the overlay element with the trigger in its last calculated position,\n   * even if a position higher in the \"preferred positions\" list would now fit. This\n   * allows one to re-align the panel without changing the orientation of the panel.\n   */\n  reapplyLastPosition() {\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n    const lastPosition = this._lastPosition;\n    if (lastPosition) {\n      this._originRect = this._getOriginRect();\n      this._overlayRect = this._pane.getBoundingClientRect();\n      this._viewportRect = this._getNarrowedViewportRect();\n      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);\n      this._applyPosition(lastPosition, originPoint);\n    } else {\n      this.apply();\n    }\n  }\n  /**\n   * Sets the list of Scrollable containers that host the origin element so that\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n   * Scrollable must be an ancestor element of the strategy's origin element.\n   */\n  withScrollableContainers(scrollables) {\n    this._scrollables = scrollables;\n    return this;\n  }\n  /**\n   * Adds new preferred positions.\n   * @param positions List of positions options for this overlay.\n   */\n  withPositions(positions) {\n    this._preferredPositions = positions;\n    // If the last calculated position object isn't part of the positions anymore, clear\n    // it in order to avoid it being picked up if the consumer tries to re-apply.\n    if (positions.indexOf(this._lastPosition) === -1) {\n      this._lastPosition = null;\n    }\n    this._validatePositions();\n    return this;\n  }\n  /**\n   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n   * @param margin Required margin between the overlay and the viewport edge in pixels.\n   */\n  withViewportMargin(margin) {\n    this._viewportMargin = margin;\n    return this;\n  }\n  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n  withFlexibleDimensions(flexibleDimensions = true) {\n    this._hasFlexibleDimensions = flexibleDimensions;\n    return this;\n  }\n  /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n  withGrowAfterOpen(growAfterOpen = true) {\n    this._growAfterOpen = growAfterOpen;\n    return this;\n  }\n  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n  withPush(canPush = true) {\n    this._canPush = canPush;\n    return this;\n  }\n  /**\n   * Sets whether the overlay's position should be locked in after it is positioned\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\n   * when the position is re-applied (e.g. when the user scrolls away).\n   * @param isLocked Whether the overlay should locked in.\n   */\n  withLockedPosition(isLocked = true) {\n    this._positionLocked = isLocked;\n    return this;\n  }\n  /**\n   * Sets the origin, relative to which to position the overlay.\n   * Using an element origin is useful for building components that need to be positioned\n   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n   * used for cases like contextual menus which open relative to the user's pointer.\n   * @param origin Reference to the new origin.\n   */\n  setOrigin(origin) {\n    this._origin = origin;\n    return this;\n  }\n  /**\n   * Sets the default offset for the overlay's connection point on the x-axis.\n   * @param offset New offset in the X axis.\n   */\n  withDefaultOffsetX(offset) {\n    this._offsetX = offset;\n    return this;\n  }\n  /**\n   * Sets the default offset for the overlay's connection point on the y-axis.\n   * @param offset New offset in the Y axis.\n   */\n  withDefaultOffsetY(offset) {\n    this._offsetY = offset;\n    return this;\n  }\n  /**\n   * Configures that the position strategy should set a `transform-origin` on some elements\n   * inside the overlay, depending on the current position that is being applied. This is\n   * useful for the cases where the origin of an animation can change depending on the\n   * alignment of the overlay.\n   * @param selector CSS selector that will be used to find the target\n   *    elements onto which to set the transform origin.\n   */\n  withTransformOriginOn(selector) {\n    this._transformOriginSelector = selector;\n    return this;\n  }\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   */\n  _getOriginPoint(originRect, containerRect, pos) {\n    let x;\n    if (pos.originX == 'center') {\n      // Note: when centering we should always use the `left`\n      // offset, otherwise the position will be wrong in RTL.\n      x = originRect.left + originRect.width / 2;\n    } else {\n      const startX = this._isRtl() ? originRect.right : originRect.left;\n      const endX = this._isRtl() ? originRect.left : originRect.right;\n      x = pos.originX == 'start' ? startX : endX;\n    }\n    // When zooming in Safari the container rectangle contains negative values for the position\n    // and we need to re-add them to the calculated coordinates.\n    if (containerRect.left < 0) {\n      x -= containerRect.left;\n    }\n    let y;\n    if (pos.originY == 'center') {\n      y = originRect.top + originRect.height / 2;\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n    // Normally the containerRect's top value would be zero, however when the overlay is attached to an input\n    // (e.g. in an autocomplete), mobile browsers will shift everything in order to put the input in the middle\n    // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n    // otherwise our positioning will be thrown off.\n    // Additionally, when zooming in Safari this fixes the vertical position.\n    if (containerRect.top < 0) {\n      y -= containerRect.top;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected.\n   */\n  _getOverlayPoint(originPoint, overlayRect, pos) {\n    // Calculate the (overlayStartX, overlayStartY), the start of the\n    // potential overlay position relative to the origin point.\n    let overlayStartX;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n    }\n    let overlayStartY;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n    // The (x, y) coordinates of the overlay.\n    return {\n      x: originPoint.x + overlayStartX,\n      y: originPoint.y + overlayStartY\n    };\n  }\n  /** Gets how well an overlay at the given point will fit within the viewport. */\n  _getOverlayFit(point, rawOverlayRect, viewport, position) {\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    let {\n      x,\n      y\n    } = point;\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n    // Account for the offsets since they could push the overlay out of the viewport.\n    if (offsetX) {\n      x += offsetX;\n    }\n    if (offsetY) {\n      y += offsetY;\n    }\n    // How much the overlay would overflow at this position, on each side.\n    let leftOverflow = 0 - x;\n    let rightOverflow = x + overlay.width - viewport.width;\n    let topOverflow = 0 - y;\n    let bottomOverflow = y + overlay.height - viewport.height;\n    // Visible parts of the element on each axis.\n    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n    let visibleArea = visibleWidth * visibleHeight;\n    return {\n      visibleArea,\n      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,\n      fitsInViewportVertically: visibleHeight === overlay.height,\n      fitsInViewportHorizontally: visibleWidth == overlay.width\n    };\n  }\n  /**\n   * Whether the overlay can fit within the viewport when it may resize either its width or height.\n   * @param fit How well the overlay fits in the viewport at some position.\n   * @param point The (x, y) coordinates of the overlay at some position.\n   * @param viewport The geometry of the viewport.\n   */\n  _canFitWithFlexibleDimensions(fit, point, viewport) {\n    if (this._hasFlexibleDimensions) {\n      const availableHeight = viewport.bottom - point.y;\n      const availableWidth = viewport.right - point.x;\n      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;\n      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;\n      return verticalFit && horizontalFit;\n    }\n    return false;\n  }\n  /**\n   * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n   * right and bottom).\n   *\n   * @param start Starting point from which the overlay is pushed.\n   * @param rawOverlayRect Dimensions of the overlay.\n   * @param scrollPosition Current viewport scroll position.\n   * @returns The point at which to position the overlay after pushing. This is effectively a new\n   *     originPoint.\n   */\n  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n    // If the position is locked and we've pushed the overlay already, reuse the previous push\n    // amount, rather than pushing it again. If we were to continue pushing, the element would\n    // remain in the viewport, which goes against the expectations when position locking is enabled.\n    if (this._previousPushAmount && this._positionLocked) {\n      return {\n        x: start.x + this._previousPushAmount.x,\n        y: start.y + this._previousPushAmount.y\n      };\n    }\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    const viewport = this._viewportRect;\n    // Determine how much the overlay goes outside the viewport on each\n    // side, which we'll use to decide which direction to push it.\n    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n    // Amount by which to push the overlay in each axis such that it remains on-screen.\n    let pushX = 0;\n    let pushY = 0;\n    // If the overlay fits completely within the bounds of the viewport, push it from whichever\n    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n    // viewport and allow for the trailing end of the overlay to go out of bounds.\n    if (overlay.width <= viewport.width) {\n      pushX = overflowLeft || -overflowRight;\n    } else {\n      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;\n    }\n    if (overlay.height <= viewport.height) {\n      pushY = overflowTop || -overflowBottom;\n    } else {\n      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;\n    }\n    this._previousPushAmount = {\n      x: pushX,\n      y: pushY\n    };\n    return {\n      x: start.x + pushX,\n      y: start.y + pushY\n    };\n  }\n  /**\n   * Applies a computed position to the overlay and emits a position change.\n   * @param position The position preference\n   * @param originPoint The point on the origin element where the overlay is connected.\n   */\n  _applyPosition(position, originPoint) {\n    this._setTransformOrigin(position);\n    this._setOverlayElementStyles(originPoint, position);\n    this._setBoundingBoxStyles(originPoint, position);\n    if (position.panelClass) {\n      this._addPanelClasses(position.panelClass);\n    }\n    // Notify that the position has been changed along with its change properties.\n    // We only emit if we've got any subscriptions, because the scroll visibility\n    // calculations can be somewhat expensive.\n    if (this._positionChanges.observers.length) {\n      const scrollVisibility = this._getScrollVisibility();\n      // We're recalculating on scroll, but we only want to emit if anything\n      // changed since downstream code might be hitting the `NgZone`.\n      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {\n        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);\n        this._positionChanges.next(changeEvent);\n      }\n      this._lastScrollVisibility = scrollVisibility;\n    }\n    // Save the last connected position in case the position needs to be re-calculated.\n    this._lastPosition = position;\n    this._isInitialRender = false;\n  }\n  /** Sets the transform origin based on the configured selector and the passed-in position.  */\n  _setTransformOrigin(position) {\n    if (!this._transformOriginSelector) {\n      return;\n    }\n    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n    let xOrigin;\n    let yOrigin = position.overlayY;\n    if (position.overlayX === 'center') {\n      xOrigin = 'center';\n    } else if (this._isRtl()) {\n      xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n    } else {\n      xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n    }\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n    }\n  }\n  /**\n   * Gets the position and size of the overlay's sizing container.\n   *\n   * This method does no measuring and applies no styles so that we can cheaply compute the\n   * bounds for all positions and choose the best fit based on these results.\n   */\n  _calculateBoundingBoxRect(origin, position) {\n    const viewport = this._viewportRect;\n    const isRtl = this._isRtl();\n    let height, top, bottom;\n    if (position.overlayY === 'top') {\n      // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n      top = origin.y;\n      height = viewport.height - top + this._viewportMargin;\n    } else if (position.overlayY === 'bottom') {\n      // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n      // the viewport margin back in, because the viewport rect is narrowed down to remove the\n      // margin, whereas the `origin` position is calculated based on its `DOMRect`.\n      bottom = viewport.height - origin.y + this._viewportMargin * 2;\n      height = viewport.height - bottom + this._viewportMargin;\n    } else {\n      // If neither top nor bottom, it means that the overlay is vertically centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n      // `origin.y - viewport.top`.\n      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n      const previousHeight = this._lastBoundingBoxSize.height;\n      height = smallestDistanceToViewportEdge * 2;\n      top = origin.y - smallestDistanceToViewportEdge;\n      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n        top = origin.y - previousHeight / 2;\n      }\n    }\n    // The overlay is opening 'right-ward' (the content flows to the right).\n    const isBoundedByRightViewportEdge = position.overlayX === 'start' && !isRtl || position.overlayX === 'end' && isRtl;\n    // The overlay is opening 'left-ward' (the content flows to the left).\n    const isBoundedByLeftViewportEdge = position.overlayX === 'end' && !isRtl || position.overlayX === 'start' && isRtl;\n    let width, left, right;\n    if (isBoundedByLeftViewportEdge) {\n      right = viewport.width - origin.x + this._viewportMargin * 2;\n      width = origin.x - this._viewportMargin;\n    } else if (isBoundedByRightViewportEdge) {\n      left = origin.x;\n      width = viewport.right - origin.x;\n    } else {\n      // If neither start nor end, it means that the overlay is horizontally centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.right - origin.x` and\n      // `origin.x - viewport.left`.\n      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n      const previousWidth = this._lastBoundingBoxSize.width;\n      width = smallestDistanceToViewportEdge * 2;\n      left = origin.x - smallestDistanceToViewportEdge;\n      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n        left = origin.x - previousWidth / 2;\n      }\n    }\n    return {\n      top: top,\n      left: left,\n      bottom: bottom,\n      right: right,\n      width,\n      height\n    };\n  }\n  /**\n   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n   * origin's connection point and stretches to the bounds of the viewport.\n   *\n   * @param origin The point on the origin element where the overlay is connected.\n   * @param position The position preference\n   */\n  _setBoundingBoxStyles(origin, position) {\n    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n    // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n    // when applying a new size.\n    if (!this._isInitialRender && !this._growAfterOpen) {\n      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n    }\n    const styles = {};\n    if (this._hasExactPosition()) {\n      styles.top = styles.left = '0';\n      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n      styles.width = styles.height = '100%';\n    } else {\n      const maxHeight = this._overlayRef.getConfig().maxHeight;\n      const maxWidth = this._overlayRef.getConfig().maxWidth;\n      styles.height = coerceCssPixelValue(boundingBoxRect.height);\n      styles.top = coerceCssPixelValue(boundingBoxRect.top);\n      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n      styles.width = coerceCssPixelValue(boundingBoxRect.width);\n      styles.left = coerceCssPixelValue(boundingBoxRect.left);\n      styles.right = coerceCssPixelValue(boundingBoxRect.right);\n      // Push the pane content towards the proper direction.\n      if (position.overlayX === 'center') {\n        styles.alignItems = 'center';\n      } else {\n        styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n      }\n      if (position.overlayY === 'center') {\n        styles.justifyContent = 'center';\n      } else {\n        styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n      }\n      if (maxHeight) {\n        styles.maxHeight = coerceCssPixelValue(maxHeight);\n      }\n      if (maxWidth) {\n        styles.maxWidth = coerceCssPixelValue(maxWidth);\n      }\n    }\n    this._lastBoundingBoxSize = boundingBoxRect;\n    extendStyles(this._boundingBox.style, styles);\n  }\n  /** Resets the styles for the bounding box so that a new positioning can be computed. */\n  _resetBoundingBoxStyles() {\n    extendStyles(this._boundingBox.style, {\n      top: '0',\n      left: '0',\n      right: '0',\n      bottom: '0',\n      height: '',\n      width: '',\n      alignItems: '',\n      justifyContent: ''\n    });\n  }\n  /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n  _resetOverlayElementStyles() {\n    extendStyles(this._pane.style, {\n      top: '',\n      left: '',\n      bottom: '',\n      right: '',\n      position: '',\n      transform: ''\n    });\n  }\n  /** Sets positioning styles to the overlay element. */\n  _setOverlayElementStyles(originPoint, position) {\n    const styles = {};\n    const hasExactPosition = this._hasExactPosition();\n    const hasFlexibleDimensions = this._hasFlexibleDimensions;\n    const config = this._overlayRef.getConfig();\n    if (hasExactPosition) {\n      const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n    } else {\n      styles.position = 'static';\n    }\n    // Use a transform to apply the offsets. We do this because the `center` positions rely on\n    // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n    // off the position. We also can't use margins, because they won't have an effect in some\n    // cases where the element doesn't have anything to \"push off of\". Finally, this works\n    // better both with flexible and non-flexible positioning.\n    let transformString = '';\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n    if (offsetX) {\n      transformString += `translateX(${offsetX}px) `;\n    }\n    if (offsetY) {\n      transformString += `translateY(${offsetY}px)`;\n    }\n    styles.transform = transformString.trim();\n    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n    // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n    // Note that this doesn't apply when we have an exact position, in which case we do want to\n    // apply them because they'll be cleared from the bounding box.\n    if (config.maxHeight) {\n      if (hasExactPosition) {\n        styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n      } else if (hasFlexibleDimensions) {\n        styles.maxHeight = '';\n      }\n    }\n    if (config.maxWidth) {\n      if (hasExactPosition) {\n        styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n      } else if (hasFlexibleDimensions) {\n        styles.maxWidth = '';\n      }\n    }\n    extendStyles(this._pane.style, styles);\n  }\n  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n  _getExactOverlayY(position, originPoint, scrollPosition) {\n    // Reset any existing styles. This is necessary in case the\n    // preferred position has changed since the last `apply`.\n    let styles = {\n      top: '',\n      bottom: ''\n    };\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n    // above or below the origin and the direction in which the element will expand.\n    if (position.overlayY === 'bottom') {\n      // When using `bottom`, we adjust the y position such that it is the distance\n      // from the bottom of the viewport rather than the top.\n      const documentHeight = this._document.documentElement.clientHeight;\n      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n    } else {\n      styles.top = coerceCssPixelValue(overlayPoint.y);\n    }\n    return styles;\n  }\n  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n  _getExactOverlayX(position, originPoint, scrollPosition) {\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    let styles = {\n      left: '',\n      right: ''\n    };\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let horizontalStyleProperty;\n    if (this._isRtl()) {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n    }\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    if (horizontalStyleProperty === 'right') {\n      const documentWidth = this._document.documentElement.clientWidth;\n      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n    } else {\n      styles.left = coerceCssPixelValue(overlayPoint.x);\n    }\n    return styles;\n  }\n  /**\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\n   * or completely outside the view of any of the strategy's scrollables.\n   */\n  _getScrollVisibility() {\n    // Note: needs fresh rects since the position could've changed.\n    const originBounds = this._getOriginRect();\n    const overlayBounds = this._pane.getBoundingClientRect();\n    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n    // every time, we should be able to use the scrollTop of the containers if the size of those\n    // containers hasn't changed.\n    const scrollContainerBounds = this._scrollables.map(scrollable => {\n      return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n    });\n    return {\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)\n    };\n  }\n  /** Subtracts the amount that an element is overflowing on an axis from its length. */\n  _subtractOverflows(length, ...overflows) {\n    return overflows.reduce((currentValue, currentOverflow) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n  /** Narrows the given viewport rect by the current _viewportMargin. */\n  _getNarrowedViewportRect() {\n    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n    // and `innerHeight` that do. This is necessary, because the overlay container uses\n    // 100% `width` and `height` which don't include the scrollbar either.\n    const width = this._document.documentElement.clientWidth;\n    const height = this._document.documentElement.clientHeight;\n    const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n    return {\n      top: scrollPosition.top + this._viewportMargin,\n      left: scrollPosition.left + this._viewportMargin,\n      right: scrollPosition.left + width - this._viewportMargin,\n      bottom: scrollPosition.top + height - this._viewportMargin,\n      width: width - 2 * this._viewportMargin,\n      height: height - 2 * this._viewportMargin\n    };\n  }\n  /** Whether the we're dealing with an RTL context */\n  _isRtl() {\n    return this._overlayRef.getDirection() === 'rtl';\n  }\n  /** Determines whether the overlay uses exact or flexible positioning. */\n  _hasExactPosition() {\n    return !this._hasFlexibleDimensions || this._isPushed;\n  }\n  /** Retrieves the offset of a position along the x or y axis. */\n  _getOffset(position, axis) {\n    if (axis === 'x') {\n      // We don't do something like `position['offset' + axis]` in\n      // order to avoid breaking minifiers that rename properties.\n      return position.offsetX == null ? this._offsetX : position.offsetX;\n    }\n    return position.offsetY == null ? this._offsetY : position.offsetY;\n  }\n  /** Validates that the current position match the expected values. */\n  _validatePositions() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._preferredPositions.length) {\n        throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n      }\n      // TODO(crisbeto): remove these once Angular's template type\n      // checking is advanced enough to catch these cases.\n      this._preferredPositions.forEach(pair => {\n        validateHorizontalPosition('originX', pair.originX);\n        validateVerticalPosition('originY', pair.originY);\n        validateHorizontalPosition('overlayX', pair.overlayX);\n        validateVerticalPosition('overlayY', pair.overlayY);\n      });\n    }\n  }\n  /** Adds a single CSS class or an array of classes on the overlay panel. */\n  _addPanelClasses(cssClasses) {\n    if (this._pane) {\n      coerceArray(cssClasses).forEach(cssClass => {\n        if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n          this._appliedPanelClasses.push(cssClass);\n          this._pane.classList.add(cssClass);\n        }\n      });\n    }\n  }\n  /** Clears the classes that the position strategy has applied from the overlay panel. */\n  _clearPanelClasses() {\n    if (this._pane) {\n      this._appliedPanelClasses.forEach(cssClass => {\n        this._pane.classList.remove(cssClass);\n      });\n      this._appliedPanelClasses = [];\n    }\n  }\n  /** Returns the DOMRect of the current origin. */\n  _getOriginRect() {\n    const origin = this._origin;\n    if (origin instanceof ElementRef) {\n      return origin.nativeElement.getBoundingClientRect();\n    }\n    // Check for Element so SVG elements are also supported.\n    if (origin instanceof Element) {\n      return origin.getBoundingClientRect();\n    }\n    const width = origin.width || 0;\n    const height = origin.height || 0;\n    // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n    return {\n      top: origin.y,\n      bottom: origin.y + height,\n      left: origin.x,\n      right: origin.x + width,\n      height,\n      width\n    };\n  }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) {\n      destination[key] = source[key];\n    }\n  }\n  return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n  if (typeof input !== 'number' && input != null) {\n    const [value, units] = input.split(cssUnitPattern);\n    return !units || units === 'px' ? parseFloat(value) : null;\n  }\n  return input || null;\n}\n/**\n * Gets a version of an element's bounding `DOMRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `DOMRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n  return {\n    top: Math.floor(clientRect.top),\n    right: Math.floor(clientRect.right),\n    bottom: Math.floor(clientRect.bottom),\n    left: Math.floor(clientRect.left),\n    width: Math.floor(clientRect.width),\n    height: Math.floor(clientRect.height)\n  };\n}\n/** Returns whether two `ScrollingVisibility` objects are identical. */\nfunction compareScrollVisibility(a, b) {\n  if (a === b) {\n    return true;\n  }\n  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;\n}\nconst STANDARD_DROPDOWN_BELOW_POSITIONS = [{\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'top'\n}, {\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}];\nconst STANDARD_DROPDOWN_ADJACENT_POSITIONS = [{\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}];\n\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n  constructor() {\n    this._cssPosition = 'static';\n    this._topOffset = '';\n    this._bottomOffset = '';\n    this._alignItems = '';\n    this._xPosition = '';\n    this._xOffset = '';\n    this._width = '';\n    this._height = '';\n    this._isDisposed = false;\n  }\n  attach(overlayRef) {\n    const config = overlayRef.getConfig();\n    this._overlayRef = overlayRef;\n    if (this._width && !config.width) {\n      overlayRef.updateSize({\n        width: this._width\n      });\n    }\n    if (this._height && !config.height) {\n      overlayRef.updateSize({\n        height: this._height\n      });\n    }\n    overlayRef.hostElement.classList.add(wrapperClass);\n    this._isDisposed = false;\n  }\n  /**\n   * Sets the top position of the overlay. Clears any previously set vertical position.\n   * @param value New top offset.\n   */\n  top(value = '') {\n    this._bottomOffset = '';\n    this._topOffset = value;\n    this._alignItems = 'flex-start';\n    return this;\n  }\n  /**\n   * Sets the left position of the overlay. Clears any previously set horizontal position.\n   * @param value New left offset.\n   */\n  left(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'left';\n    return this;\n  }\n  /**\n   * Sets the bottom position of the overlay. Clears any previously set vertical position.\n   * @param value New bottom offset.\n   */\n  bottom(value = '') {\n    this._topOffset = '';\n    this._bottomOffset = value;\n    this._alignItems = 'flex-end';\n    return this;\n  }\n  /**\n   * Sets the right position of the overlay. Clears any previously set horizontal position.\n   * @param value New right offset.\n   */\n  right(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'right';\n    return this;\n  }\n  /**\n   * Sets the overlay to the start of the viewport, depending on the overlay direction.\n   * This will be to the left in LTR layouts and to the right in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  start(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'start';\n    return this;\n  }\n  /**\n   * Sets the overlay to the end of the viewport, depending on the overlay direction.\n   * This will be to the right in LTR layouts and to the left in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  end(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'end';\n    return this;\n  }\n  /**\n   * Sets the overlay width and clears any previously set width.\n   * @param value New width for the overlay\n   * @deprecated Pass the `width` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  width(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        width: value\n      });\n    } else {\n      this._width = value;\n    }\n    return this;\n  }\n  /**\n   * Sets the overlay height and clears any previously set height.\n   * @param value New height for the overlay\n   * @deprecated Pass the `height` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  height(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        height: value\n      });\n    } else {\n      this._height = value;\n    }\n    return this;\n  }\n  /**\n   * Centers the overlay horizontally with an optional offset.\n   * Clears any previously set horizontal position.\n   *\n   * @param offset Overlay offset from the horizontal center.\n   */\n  centerHorizontally(offset = '') {\n    this.left(offset);\n    this._xPosition = 'center';\n    return this;\n  }\n  /**\n   * Centers the overlay vertically with an optional offset.\n   * Clears any previously set vertical position.\n   *\n   * @param offset Overlay offset from the vertical center.\n   */\n  centerVertically(offset = '') {\n    this.top(offset);\n    this._alignItems = 'center';\n    return this;\n  }\n  /**\n   * Apply the position to the element.\n   * @docs-private\n   */\n  apply() {\n    // Since the overlay ref applies the strategy asynchronously, it could\n    // have been disposed before it ends up being applied. If that is the\n    // case, we shouldn't do anything.\n    if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n      return;\n    }\n    const styles = this._overlayRef.overlayElement.style;\n    const parentStyles = this._overlayRef.hostElement.style;\n    const config = this._overlayRef.getConfig();\n    const {\n      width,\n      height,\n      maxWidth,\n      maxHeight\n    } = config;\n    const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') && (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n    const shouldBeFlushVertically = (height === '100%' || height === '100vh') && (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n    const xPosition = this._xPosition;\n    const xOffset = this._xOffset;\n    const isRtl = this._overlayRef.getConfig().direction === 'rtl';\n    let marginLeft = '';\n    let marginRight = '';\n    let justifyContent = '';\n    if (shouldBeFlushHorizontally) {\n      justifyContent = 'flex-start';\n    } else if (xPosition === 'center') {\n      justifyContent = 'center';\n      if (isRtl) {\n        marginRight = xOffset;\n      } else {\n        marginLeft = xOffset;\n      }\n    } else if (isRtl) {\n      if (xPosition === 'left' || xPosition === 'end') {\n        justifyContent = 'flex-end';\n        marginLeft = xOffset;\n      } else if (xPosition === 'right' || xPosition === 'start') {\n        justifyContent = 'flex-start';\n        marginRight = xOffset;\n      }\n    } else if (xPosition === 'left' || xPosition === 'start') {\n      justifyContent = 'flex-start';\n      marginLeft = xOffset;\n    } else if (xPosition === 'right' || xPosition === 'end') {\n      justifyContent = 'flex-end';\n      marginRight = xOffset;\n    }\n    styles.position = this._cssPosition;\n    styles.marginLeft = shouldBeFlushHorizontally ? '0' : marginLeft;\n    styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n    styles.marginBottom = this._bottomOffset;\n    styles.marginRight = shouldBeFlushHorizontally ? '0' : marginRight;\n    parentStyles.justifyContent = justifyContent;\n    parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n  }\n  /**\n   * Cleans up the DOM changes from the position strategy.\n   * @docs-private\n   */\n  dispose() {\n    if (this._isDisposed || !this._overlayRef) {\n      return;\n    }\n    const styles = this._overlayRef.overlayElement.style;\n    const parent = this._overlayRef.hostElement;\n    const parentStyles = parent.style;\n    parent.classList.remove(wrapperClass);\n    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n    this._overlayRef = null;\n    this._isDisposed = true;\n  }\n}\n\n/** Builder for overlay position strategy. */\nclass OverlayPositionBuilder {\n  constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n    this._platform = _platform;\n    this._overlayContainer = _overlayContainer;\n  }\n  /**\n   * Creates a global position strategy.\n   */\n  global() {\n    return new GlobalPositionStrategy();\n  }\n  /**\n   * Creates a flexible position strategy.\n   * @param origin Origin relative to which to position the overlay.\n   */\n  flexibleConnectedTo(origin) {\n    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n  }\n  static {\n    this.ɵfac = function OverlayPositionBuilder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || OverlayPositionBuilder)(i0.ɵɵinject(i1.ViewportRuler), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1$1.Platform), i0.ɵɵinject(OverlayContainer));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: OverlayPositionBuilder,\n      factory: OverlayPositionBuilder.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverlayPositionBuilder, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i1.ViewportRuler\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }, {\n    type: OverlayContainer\n  }], null);\n})();\n\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\n// Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n// which needs to be different depending on where OverlayModule is imported.\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n  constructor( /** Scrolling strategies that can be used when creating an overlay. */\n  scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher, _animationsModuleType) {\n    this.scrollStrategies = scrollStrategies;\n    this._overlayContainer = _overlayContainer;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._positionBuilder = _positionBuilder;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._injector = _injector;\n    this._ngZone = _ngZone;\n    this._document = _document;\n    this._directionality = _directionality;\n    this._location = _location;\n    this._outsideClickDispatcher = _outsideClickDispatcher;\n    this._animationsModuleType = _animationsModuleType;\n  }\n  /**\n   * Creates an overlay.\n   * @param config Configuration applied to the overlay.\n   * @returns Reference to the created overlay.\n   */\n  create(config) {\n    const host = this._createHostElement();\n    const pane = this._createPaneElement(host);\n    const portalOutlet = this._createPortalOutlet(pane);\n    const overlayConfig = new OverlayConfig(config);\n    overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === 'NoopAnimations', this._injector.get(EnvironmentInjector));\n  }\n  /**\n   * Gets a position builder that can be used, via fluent API,\n   * to construct and configure a position strategy.\n   * @returns An overlay position builder.\n   */\n  position() {\n    return this._positionBuilder;\n  }\n  /**\n   * Creates the DOM element for an overlay and appends it to the overlay container.\n   * @returns Newly-created pane element\n   */\n  _createPaneElement(host) {\n    const pane = this._document.createElement('div');\n    pane.id = `cdk-overlay-${nextUniqueId++}`;\n    pane.classList.add('cdk-overlay-pane');\n    host.appendChild(pane);\n    return pane;\n  }\n  /**\n   * Creates the host element that wraps around an overlay\n   * and can be used for advanced positioning.\n   * @returns Newly-create host element.\n   */\n  _createHostElement() {\n    const host = this._document.createElement('div');\n    this._overlayContainer.getContainerElement().appendChild(host);\n    return host;\n  }\n  /**\n   * Create a DomPortalOutlet into which the overlay content can be loaded.\n   * @param pane The DOM element to turn into a portal outlet.\n   * @returns A portal outlet for the given DOM element.\n   */\n  _createPortalOutlet(pane) {\n    // We have to resolve the ApplicationRef later in order to allow people\n    // to use overlay-based providers during app initialization.\n    if (!this._appRef) {\n      this._appRef = this._injector.get(ApplicationRef);\n    }\n    return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n  }\n  static {\n    this.ɵfac = function Overlay_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Overlay)(i0.ɵɵinject(ScrollStrategyOptions), i0.ɵɵinject(OverlayContainer), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(OverlayPositionBuilder), i0.ɵɵinject(OverlayKeyboardDispatcher), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i5.Directionality), i0.ɵɵinject(i6.Location), i0.ɵɵinject(OverlayOutsideClickDispatcher), i0.ɵɵinject(ANIMATION_MODULE_TYPE, 8));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Overlay,\n      factory: Overlay.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Overlay, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: ScrollStrategyOptions\n  }, {\n    type: OverlayContainer\n  }, {\n    type: i0.ComponentFactoryResolver\n  }, {\n    type: OverlayPositionBuilder\n  }, {\n    type: OverlayKeyboardDispatcher\n  }, {\n    type: i0.Injector\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i5.Directionality\n  }, {\n    type: i6.Location\n  }, {\n    type: OverlayOutsideClickDispatcher\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [ANIMATION_MODULE_TYPE]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\n\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [{\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'top'\n}];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition();\n  }\n});\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n  constructor( /** Reference to the element on which the directive is applied. */\n  elementRef) {\n    this.elementRef = elementRef;\n  }\n  static {\n    this.ɵfac = function CdkOverlayOrigin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkOverlayOrigin)(i0.ɵɵdirectiveInject(i0.ElementRef));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkOverlayOrigin,\n      selectors: [[\"\", \"cdk-overlay-origin\", \"\"], [\"\", \"overlay-origin\", \"\"], [\"\", \"cdkOverlayOrigin\", \"\"]],\n      exportAs: [\"cdkOverlayOrigin\"],\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkOverlayOrigin, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n      exportAs: 'cdkOverlayOrigin',\n      standalone: true\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }], null);\n})();\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n  /** The offset in pixels for the overlay connection point on the x-axis */\n  get offsetX() {\n    return this._offsetX;\n  }\n  set offsetX(offsetX) {\n    this._offsetX = offsetX;\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n  /** The offset in pixels for the overlay connection point on the y-axis */\n  get offsetY() {\n    return this._offsetY;\n  }\n  set offsetY(offsetY) {\n    this._offsetY = offsetY;\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */\n  get disposeOnNavigation() {\n    return this._disposeOnNavigation;\n  }\n  set disposeOnNavigation(value) {\n    this._disposeOnNavigation = value;\n  }\n  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n  constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n    this._overlay = _overlay;\n    this._dir = _dir;\n    this._backdropSubscription = Subscription.EMPTY;\n    this._attachSubscription = Subscription.EMPTY;\n    this._detachSubscription = Subscription.EMPTY;\n    this._positionSubscription = Subscription.EMPTY;\n    this._disposeOnNavigation = false;\n    this._ngZone = inject(NgZone);\n    /** Margin between the overlay and the viewport edges. */\n    this.viewportMargin = 0;\n    /** Whether the overlay is open. */\n    this.open = false;\n    /** Whether the overlay can be closed by user interaction. */\n    this.disableClose = false;\n    /** Whether or not the overlay should attach a backdrop. */\n    this.hasBackdrop = false;\n    /** Whether or not the overlay should be locked when scrolling. */\n    this.lockPosition = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    this.flexibleDimensions = false;\n    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n    this.growAfterOpen = false;\n    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    this.push = false;\n    /** Event emitted when the backdrop is clicked. */\n    this.backdropClick = new EventEmitter();\n    /** Event emitted when the position has changed. */\n    this.positionChange = new EventEmitter();\n    /** Event emitted when the overlay has been attached. */\n    this.attach = new EventEmitter();\n    /** Event emitted when the overlay has been detached. */\n    this.detach = new EventEmitter();\n    /** Emits when there are keyboard events that are targeted at the overlay. */\n    this.overlayKeydown = new EventEmitter();\n    /** Emits when there are mouse outside click events that are targeted at the overlay. */\n    this.overlayOutsideClick = new EventEmitter();\n    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this.scrollStrategy = this._scrollStrategyFactory();\n  }\n  /** The associated overlay reference. */\n  get overlayRef() {\n    return this._overlayRef;\n  }\n  /** The element's layout direction. */\n  get dir() {\n    return this._dir ? this._dir.value : 'ltr';\n  }\n  ngOnDestroy() {\n    this._attachSubscription.unsubscribe();\n    this._detachSubscription.unsubscribe();\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n    }\n  }\n  ngOnChanges(changes) {\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n      this._overlayRef.updateSize({\n        width: this.width,\n        minWidth: this.minWidth,\n        height: this.height,\n        minHeight: this.minHeight\n      });\n      if (changes['origin'] && this.open) {\n        this._position.apply();\n      }\n    }\n    if (changes['open']) {\n      this.open ? this._attachOverlay() : this._detachOverlay();\n    }\n  }\n  /** Creates an overlay */\n  _createOverlay() {\n    if (!this.positions || !this.positions.length) {\n      this.positions = defaultPositionList;\n    }\n    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());\n    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n    overlayRef.keydownEvents().subscribe(event => {\n      this.overlayKeydown.next(event);\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this._detachOverlay();\n      }\n    });\n    this._overlayRef.outsidePointerEvents().subscribe(event => {\n      const origin = this._getOriginElement();\n      const target = _getEventTarget(event);\n      if (!origin || origin !== target && !origin.contains(target)) {\n        this.overlayOutsideClick.next(event);\n      }\n    });\n  }\n  /** Builds the overlay config based on the directive's inputs */\n  _buildConfig() {\n    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();\n    const overlayConfig = new OverlayConfig({\n      direction: this._dir,\n      positionStrategy,\n      scrollStrategy: this.scrollStrategy,\n      hasBackdrop: this.hasBackdrop,\n      disposeOnNavigation: this.disposeOnNavigation\n    });\n    if (this.width || this.width === 0) {\n      overlayConfig.width = this.width;\n    }\n    if (this.height || this.height === 0) {\n      overlayConfig.height = this.height;\n    }\n    if (this.minWidth || this.minWidth === 0) {\n      overlayConfig.minWidth = this.minWidth;\n    }\n    if (this.minHeight || this.minHeight === 0) {\n      overlayConfig.minHeight = this.minHeight;\n    }\n    if (this.backdropClass) {\n      overlayConfig.backdropClass = this.backdropClass;\n    }\n    if (this.panelClass) {\n      overlayConfig.panelClass = this.panelClass;\n    }\n    return overlayConfig;\n  }\n  /** Updates the state of a position strategy, based on the values of the directive inputs. */\n  _updatePositionStrategy(positionStrategy) {\n    const positions = this.positions.map(currentPosition => ({\n      originX: currentPosition.originX,\n      originY: currentPosition.originY,\n      overlayX: currentPosition.overlayX,\n      overlayY: currentPosition.overlayY,\n      offsetX: currentPosition.offsetX || this.offsetX,\n      offsetY: currentPosition.offsetY || this.offsetY,\n      panelClass: currentPosition.panelClass || undefined\n    }));\n    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);\n  }\n  /** Returns the position strategy of the overlay to be set on the overlay config */\n  _createPositionStrategy() {\n    const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());\n    this._updatePositionStrategy(strategy);\n    return strategy;\n  }\n  _getOrigin() {\n    if (this.origin instanceof CdkOverlayOrigin) {\n      return this.origin.elementRef;\n    } else {\n      return this.origin;\n    }\n  }\n  _getOriginElement() {\n    if (this.origin instanceof CdkOverlayOrigin) {\n      return this.origin.elementRef.nativeElement;\n    }\n    if (this.origin instanceof ElementRef) {\n      return this.origin.nativeElement;\n    }\n    if (typeof Element !== 'undefined' && this.origin instanceof Element) {\n      return this.origin;\n    }\n    return null;\n  }\n  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n  _attachOverlay() {\n    if (!this._overlayRef) {\n      this._createOverlay();\n    } else {\n      // Update the overlay size, in case the directive's inputs have changed\n      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n    }\n    if (!this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._templatePortal);\n    }\n    if (this.hasBackdrop) {\n      this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n        this.backdropClick.emit(event);\n      });\n    } else {\n      this._backdropSubscription.unsubscribe();\n    }\n    this._positionSubscription.unsubscribe();\n    // Only subscribe to `positionChanges` if requested, because putting\n    // together all the information for it can be expensive.\n    if (this.positionChange.observers.length > 0) {\n      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe(position => {\n        this._ngZone.run(() => this.positionChange.emit(position));\n        if (this.positionChange.observers.length === 0) {\n          this._positionSubscription.unsubscribe();\n        }\n      });\n    }\n  }\n  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n  _detachOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.detach();\n    }\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n  }\n  static {\n    this.ɵfac = function CdkConnectedOverlay_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkConnectedOverlay)(i0.ɵɵdirectiveInject(Overlay), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), i0.ɵɵdirectiveInject(i5.Directionality, 8));\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkConnectedOverlay,\n      selectors: [[\"\", \"cdk-connected-overlay\", \"\"], [\"\", \"connected-overlay\", \"\"], [\"\", \"cdkConnectedOverlay\", \"\"]],\n      inputs: {\n        origin: [0, \"cdkConnectedOverlayOrigin\", \"origin\"],\n        positions: [0, \"cdkConnectedOverlayPositions\", \"positions\"],\n        positionStrategy: [0, \"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"],\n        offsetX: [0, \"cdkConnectedOverlayOffsetX\", \"offsetX\"],\n        offsetY: [0, \"cdkConnectedOverlayOffsetY\", \"offsetY\"],\n        width: [0, \"cdkConnectedOverlayWidth\", \"width\"],\n        height: [0, \"cdkConnectedOverlayHeight\", \"height\"],\n        minWidth: [0, \"cdkConnectedOverlayMinWidth\", \"minWidth\"],\n        minHeight: [0, \"cdkConnectedOverlayMinHeight\", \"minHeight\"],\n        backdropClass: [0, \"cdkConnectedOverlayBackdropClass\", \"backdropClass\"],\n        panelClass: [0, \"cdkConnectedOverlayPanelClass\", \"panelClass\"],\n        viewportMargin: [0, \"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"],\n        scrollStrategy: [0, \"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"],\n        open: [0, \"cdkConnectedOverlayOpen\", \"open\"],\n        disableClose: [0, \"cdkConnectedOverlayDisableClose\", \"disableClose\"],\n        transformOriginSelector: [0, \"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"],\n        hasBackdrop: [2, \"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\", booleanAttribute],\n        lockPosition: [2, \"cdkConnectedOverlayLockPosition\", \"lockPosition\", booleanAttribute],\n        flexibleDimensions: [2, \"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\", booleanAttribute],\n        growAfterOpen: [2, \"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\", booleanAttribute],\n        push: [2, \"cdkConnectedOverlayPush\", \"push\", booleanAttribute],\n        disposeOnNavigation: [2, \"cdkConnectedOverlayDisposeOnNavigation\", \"disposeOnNavigation\", booleanAttribute]\n      },\n      outputs: {\n        backdropClick: \"backdropClick\",\n        positionChange: \"positionChange\",\n        attach: \"attach\",\n        detach: \"detach\",\n        overlayKeydown: \"overlayKeydown\",\n        overlayOutsideClick: \"overlayOutsideClick\"\n      },\n      exportAs: [\"cdkConnectedOverlay\"],\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkConnectedOverlay, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n      exportAs: 'cdkConnectedOverlay',\n      standalone: true\n    }]\n  }], () => [{\n    type: Overlay\n  }, {\n    type: i0.TemplateRef\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: i5.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }], {\n    origin: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOrigin']\n    }],\n    positions: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPositions']\n    }],\n    positionStrategy: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPositionStrategy']\n    }],\n    offsetX: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOffsetX']\n    }],\n    offsetY: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOffsetY']\n    }],\n    width: [{\n      type: Input,\n      args: ['cdkConnectedOverlayWidth']\n    }],\n    height: [{\n      type: Input,\n      args: ['cdkConnectedOverlayHeight']\n    }],\n    minWidth: [{\n      type: Input,\n      args: ['cdkConnectedOverlayMinWidth']\n    }],\n    minHeight: [{\n      type: Input,\n      args: ['cdkConnectedOverlayMinHeight']\n    }],\n    backdropClass: [{\n      type: Input,\n      args: ['cdkConnectedOverlayBackdropClass']\n    }],\n    panelClass: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPanelClass']\n    }],\n    viewportMargin: [{\n      type: Input,\n      args: ['cdkConnectedOverlayViewportMargin']\n    }],\n    scrollStrategy: [{\n      type: Input,\n      args: ['cdkConnectedOverlayScrollStrategy']\n    }],\n    open: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOpen']\n    }],\n    disableClose: [{\n      type: Input,\n      args: ['cdkConnectedOverlayDisableClose']\n    }],\n    transformOriginSelector: [{\n      type: Input,\n      args: ['cdkConnectedOverlayTransformOriginOn']\n    }],\n    hasBackdrop: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayHasBackdrop',\n        transform: booleanAttribute\n      }]\n    }],\n    lockPosition: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayLockPosition',\n        transform: booleanAttribute\n      }]\n    }],\n    flexibleDimensions: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayFlexibleDimensions',\n        transform: booleanAttribute\n      }]\n    }],\n    growAfterOpen: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayGrowAfterOpen',\n        transform: booleanAttribute\n      }]\n    }],\n    push: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayPush',\n        transform: booleanAttribute\n      }]\n    }],\n    disposeOnNavigation: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayDisposeOnNavigation',\n        transform: booleanAttribute\n      }]\n    }],\n    backdropClick: [{\n      type: Output\n    }],\n    positionChange: [{\n      type: Output\n    }],\n    attach: [{\n      type: Output\n    }],\n    detach: [{\n      type: Output\n    }],\n    overlayKeydown: [{\n      type: Output\n    }],\n    overlayOutsideClick: [{\n      type: Output\n    }]\n  });\n})();\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\nclass OverlayModule {\n  static {\n    this.ɵfac = function OverlayModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || OverlayModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: OverlayModule,\n      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n      imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverlayModule, [{\n    type: NgModule,\n    args: [{\n      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]\n    }]\n  }], null, null);\n})();\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n  constructor(_document, platform) {\n    super(_document, platform);\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    if (this._fullScreenEventName && this._fullScreenListener) {\n      this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n    }\n  }\n  _createContainer() {\n    super._createContainer();\n    this._adjustParentForFullscreenChange();\n    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n  }\n  _adjustParentForFullscreenChange() {\n    if (!this._containerElement) {\n      return;\n    }\n    const fullscreenElement = this.getFullscreenElement();\n    const parent = fullscreenElement || this._document.body;\n    parent.appendChild(this._containerElement);\n  }\n  _addFullscreenChangeListener(fn) {\n    const eventName = this._getEventName();\n    if (eventName) {\n      if (this._fullScreenListener) {\n        this._document.removeEventListener(eventName, this._fullScreenListener);\n      }\n      this._document.addEventListener(eventName, fn);\n      this._fullScreenListener = fn;\n    }\n  }\n  _getEventName() {\n    if (!this._fullScreenEventName) {\n      const _document = this._document;\n      if (_document.fullscreenEnabled) {\n        this._fullScreenEventName = 'fullscreenchange';\n      } else if (_document.webkitFullscreenEnabled) {\n        this._fullScreenEventName = 'webkitfullscreenchange';\n      } else if (_document.mozFullScreenEnabled) {\n        this._fullScreenEventName = 'mozfullscreenchange';\n      } else if (_document.msFullscreenEnabled) {\n        this._fullScreenEventName = 'MSFullscreenChange';\n      }\n    }\n    return this._fullScreenEventName;\n  }\n  /**\n   * When the page is put into fullscreen mode, a specific element is specified.\n   * Only that element and its children are visible when in fullscreen mode.\n   */\n  getFullscreenElement() {\n    const _document = this._document;\n    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;\n  }\n  static {\n    this.ɵfac = function FullscreenOverlayContainer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FullscreenOverlayContainer)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1$1.Platform));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: FullscreenOverlayContainer,\n      factory: FullscreenOverlayContainer.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FullscreenOverlayContainer, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlockScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, CloseScrollStrategy, ConnectedOverlayPositionChange, ConnectionPositionPair, FlexibleConnectedPositionStrategy, FullscreenOverlayContainer, GlobalPositionStrategy, NoopScrollStrategy, Overlay, OverlayConfig, OverlayContainer, OverlayKeyboardDispatcher, OverlayModule, OverlayOutsideClickDispatcher, OverlayPositionBuilder, OverlayRef, RepositionScrollStrategy, STANDARD_DROPDOWN_ADJACENT_POSITIONS, STANDARD_DROPDOWN_BELOW_POSITIONS, ScrollStrategyOptions, ScrollingVisibility, validateHorizontalPosition, validateVerticalPosition };\n", "import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Optional, SkipSelf, Inject, Injectable, inject, Injector, ViewContainerRef, EventEmitter, NgZone, ElementRef, ChangeDetectorRef, booleanAttribute, Input, Output, signal, computed, ContentChildren, NgModule } from '@angular/core';\nimport { Overlay, OverlayConfig, STANDARD_DROPDOWN_BELOW_POSITIONS, STANDARD_DROPDOWN_ADJACENT_POSITIONS, OverlayModule } from '@angular/cdk/overlay';\nimport { ENTER, SPACE, UP_ARROW, hasModifierKey, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, TAB, ESCAPE } from '@angular/cdk/keycodes';\nimport { startWith, debounceTime, distinctUntilChanged, filter, takeUntil, mergeMap, mapTo, mergeAll, switchMap, skipWhile, skip } from 'rxjs/operators';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { Subject, merge, fromEvent, defer, partition } from 'rxjs';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { InputModalityDetector, FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { _getEventTarget } from '@angular/cdk/platform';\n\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\nclass CdkMenuGroup {\n  static {\n    this.ɵfac = function CdkMenuGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuGroup)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuGroup,\n      selectors: [[\"\", \"cdkMenuGroup\", \"\"]],\n      hostAttrs: [\"role\", \"group\", 1, \"cdk-menu-group\"],\n      exportAs: [\"cdkMenuGroup\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: UniqueSelectionDispatcher,\n        useClass: UniqueSelectionDispatcher\n      }])]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuGroup, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuGroup]',\n      exportAs: 'cdkMenuGroup',\n      standalone: true,\n      host: {\n        'role': 'group',\n        'class': 'cdk-menu-group'\n      },\n      providers: [{\n        provide: UniqueSelectionDispatcher,\n        useClass: UniqueSelectionDispatcher\n      }]\n    }]\n  }], null, null);\n})();\n\n/** Injection token used to return classes implementing the Menu interface */\nconst CDK_MENU = new InjectionToken('cdk-menu');\n\n/** The relative item in the inline menu to focus after closing all popup menus. */\nvar FocusNext;\n(function (FocusNext) {\n  FocusNext[FocusNext[\"nextItem\"] = 0] = \"nextItem\";\n  FocusNext[FocusNext[\"previousItem\"] = 1] = \"previousItem\";\n  FocusNext[FocusNext[\"currentItem\"] = 2] = \"currentItem\";\n})(FocusNext || (FocusNext = {}));\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_STACK = new InjectionToken('cdk-menu-stack');\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\nconst PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || new MenuStack()\n};\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\nconst PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = orientation => ({\n  provide: MENU_STACK,\n  deps: [[new Optional(), new SkipSelf(), new Inject(MENU_STACK)]],\n  useFactory: parentMenuStack => parentMenuStack || MenuStack.inline(orientation)\n});\n/** The next available menu stack ID. */\nlet nextId$2 = 0;\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\nclass MenuStack {\n  constructor() {\n    /** The ID of this menu stack. */\n    this.id = `${nextId$2++}`;\n    /** All MenuStackItems tracked by this MenuStack. */\n    this._elements = [];\n    /** Emits the element which was popped off of the stack when requested by a closer. */\n    this._close = new Subject();\n    /** Emits once the MenuStack has become empty after popping off elements. */\n    this._empty = new Subject();\n    /** Emits whether any menu in the menu stack has focus. */\n    this._hasFocus = new Subject();\n    /** Observable which emits the MenuStackItem which has been requested to close. */\n    this.closed = this._close;\n    /** Observable which emits whether any menu in the menu stack has focus. */\n    this.hasFocus = this._hasFocus.pipe(startWith(false), debounceTime(0), distinctUntilChanged());\n    /**\n     * Observable which emits when the MenuStack is empty after popping off the last element. It\n     * emits a FocusNext event which specifies the action the closer has requested the listener\n     * perform.\n     */\n    this.emptied = this._empty;\n    /**\n     * Whether the inline menu associated with this menu stack is vertical or horizontal.\n     * `null` indicates there is no inline menu associated with this menu stack.\n     */\n    this._inlineMenuOrientation = null;\n  }\n  /** Creates a menu stack that originates from an inline menu. */\n  static inline(orientation) {\n    const stack = new MenuStack();\n    stack._inlineMenuOrientation = orientation;\n    return stack;\n  }\n  /**\n   * Adds an item to the menu stack.\n   * @param menu the MenuStackItem to put on the stack.\n   */\n  push(menu) {\n    this._elements.push(menu);\n  }\n  /**\n   * Pop items off of the stack up to and including `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the last item to pop off the stack.\n   * @param options Options that configure behavior on close.\n   */\n  close(lastItem, options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    if (this._elements.indexOf(lastItem) >= 0) {\n      let poppedElement;\n      do {\n        poppedElement = this._elements.pop();\n        this._close.next({\n          item: poppedElement,\n          focusParentTrigger\n        });\n      } while (poppedElement !== lastItem);\n      if (this.isEmpty()) {\n        this._empty.next(focusNextOnEmpty);\n      }\n    }\n  }\n  /**\n   * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the element which should be left on the stack\n   * @return whether or not an item was removed from the stack\n   */\n  closeSubMenuOf(lastItem) {\n    let removed = false;\n    if (this._elements.indexOf(lastItem) >= 0) {\n      removed = this.peek() !== lastItem;\n      while (this.peek() !== lastItem) {\n        this._close.next({\n          item: this._elements.pop()\n        });\n      }\n    }\n    return removed;\n  }\n  /**\n   * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n   * @param options Options that configure behavior on close.\n   */\n  closeAll(options) {\n    const {\n      focusNextOnEmpty,\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    if (!this.isEmpty()) {\n      while (!this.isEmpty()) {\n        const menuStackItem = this._elements.pop();\n        if (menuStackItem) {\n          this._close.next({\n            item: menuStackItem,\n            focusParentTrigger\n          });\n        }\n      }\n      this._empty.next(focusNextOnEmpty);\n    }\n  }\n  /** Return true if this stack is empty. */\n  isEmpty() {\n    return !this._elements.length;\n  }\n  /** Return the length of the stack. */\n  length() {\n    return this._elements.length;\n  }\n  /** Get the top most element on the stack. */\n  peek() {\n    return this._elements[this._elements.length - 1];\n  }\n  /** Whether the menu stack is associated with an inline menu. */\n  hasInlineMenu() {\n    return this._inlineMenuOrientation != null;\n  }\n  /** The orientation of the associated inline menu. */\n  inlineMenuOrientation() {\n    return this._inlineMenuOrientation;\n  }\n  /** Sets whether the menu stack contains the focused element. */\n  setHasFocus(hasFocus) {\n    this._hasFocus.next(hasFocus);\n  }\n  static {\n    this.ɵfac = function MenuStack_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MenuStack)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MenuStack,\n      factory: MenuStack.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MenuStack, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/** Injection token used for an implementation of MenuStack. */\nconst MENU_TRIGGER = new InjectionToken('cdk-menu-trigger');\n/** Injection token used to configure the behavior of the menu when the page is scrolled. */\nconst MENU_SCROLL_STRATEGY = new InjectionToken('cdk-menu-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition();\n  }\n});\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\nclass CdkMenuTriggerBase {\n  constructor() {\n    /** The DI injector for this component. */\n    this.injector = inject(Injector);\n    /** The view container ref for this component */\n    this.viewContainerRef = inject(ViewContainerRef);\n    /** The menu stack in which this menu resides. */\n    this.menuStack = inject(MENU_STACK);\n    /** Function used to configure the scroll strategy for the menu. */\n    this.menuScrollStrategy = inject(MENU_SCROLL_STRATEGY);\n    /** Emits when the attached menu is requested to open */\n    this.opened = new EventEmitter();\n    /** Emits when the attached menu is requested to close */\n    this.closed = new EventEmitter();\n    /** A reference to the overlay which manages the triggered menu */\n    this.overlayRef = null;\n    /** Emits when this trigger is destroyed. */\n    this.destroyed = new Subject();\n    /** Emits when the outside pointer events listener on the overlay should be stopped. */\n    this.stopOutsideClicksListener = merge(this.closed, this.destroyed);\n  }\n  ngOnDestroy() {\n    this._destroyOverlay();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Whether the attached menu is open. */\n  isOpen() {\n    return !!this.overlayRef?.hasAttached();\n  }\n  /** Registers a child menu as having been opened by this trigger. */\n  registerChildMenu(child) {\n    this.childMenu = child;\n  }\n  /**\n   * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n   * content to change dynamically and be reflected in the application.\n   */\n  getMenuContentPortal() {\n    const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n    if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n      this._menuPortal = new TemplatePortal(this.menuTemplateRef, this.viewContainerRef, this.menuData, this._getChildMenuInjector());\n    }\n    return this._menuPortal;\n  }\n  /**\n   * Whether the given element is inside the scope of this trigger's menu stack.\n   * @param element The element to check.\n   * @return Whether the element is inside the scope of this trigger's menu stack.\n   */\n  isElementInsideMenuStack(element) {\n    for (let el = element; el; el = el?.parentElement ?? null) {\n      if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** Destroy and unset the overlay reference it if exists */\n  _destroyOverlay() {\n    if (this.overlayRef) {\n      this.overlayRef.dispose();\n      this.overlayRef = null;\n    }\n  }\n  /** Gets the injector to use when creating a child menu. */\n  _getChildMenuInjector() {\n    this._childMenuInjector = this._childMenuInjector || Injector.create({\n      providers: [{\n        provide: MENU_TRIGGER,\n        useValue: this\n      }, {\n        provide: MENU_STACK,\n        useValue: this.menuStack\n      }],\n      parent: this.injector\n    });\n    return this._childMenuInjector;\n  }\n  static {\n    this.ɵfac = function CdkMenuTriggerBase_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuTriggerBase)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuTriggerBase,\n      hostVars: 2,\n      hostBindings: function CdkMenuTriggerBase_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-controls\", ctx.childMenu == null ? null : ctx.childMenu.id)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n        }\n      },\n      standalone: true\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTriggerBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-controls]': 'childMenu?.id',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id'\n      },\n      standalone: true\n    }]\n  }], null, null);\n})();\n\n/**\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\n * @docs-private\n */\nfunction throwMissingPointerFocusTracker() {\n  throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n/**\n * Throws an exception when a reference to the parent menu is not provided.\n * @docs-private\n */\nfunction throwMissingMenuReference() {\n  throw Error('expected a reference to the parent menu');\n}\n\n/** Injection token used for an implementation of MenuAim. */\nconst MENU_AIM = new InjectionToken('cdk-menu-aim');\n/** Capture every nth mouse move event. */\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n/** The number of mouse move events to track. */\nconst NUM_POINTS = 5;\n/**\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\n * predicted to go into.\n */\nconst CLOSE_DELAY = 300;\n/** Calculate the slope between point a and b. */\nfunction getSlope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n/** Calculate the y intercept for the given point and slope. */\nfunction getYIntercept(point, slope) {\n  return point.y - slope * point.x;\n}\n/**\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\n * submenu as defined by `submenuPoints`\n * @param submenuPoints the submenu DOMRect points.\n * @param m the slope of the trajectory line.\n * @param b the y intercept of the trajectory line.\n * @return true if any point on the line falls within the submenu.\n */\nfunction isWithinSubmenu(submenuPoints, m, b) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = submenuPoints;\n  // Check for intersection with each edge of the submenu (left, right, top, bottom)\n  // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n  // other coordinate is within bounds.\n  return m * left + b >= top && m * left + b <= bottom || m * right + b >= top && m * right + b <= bottom || (top - b) / m >= left && (top - b) / m <= right || (bottom - b) / m >= left && (bottom - b) / m <= right;\n}\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\nclass TargetMenuAim {\n  constructor() {\n    /** The Angular zone. */\n    this._ngZone = inject(NgZone);\n    /** The last NUM_POINTS mouse move events. */\n    this._points = [];\n    /** Emits when this service is destroyed. */\n    this._destroyed = new Subject();\n  }\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\n   * Set the Menu and its PointerFocusTracker.\n   * @param menu The menu that this menu aim service controls.\n   * @param pointerTracker The `PointerFocusTracker` for the given menu.\n   */\n  initialize(menu, pointerTracker) {\n    this._menu = menu;\n    this._pointerTracker = pointerTracker;\n    this._subscribeToMouseMoves();\n  }\n  /**\n   * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n   * the submenu.\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n  toggle(doToggle) {\n    // If the menu is horizontal the sub-menus open below and there is no risk of premature\n    // closing of any sub-menus therefore we automatically resolve the callback.\n    if (this._menu.orientation === 'horizontal') {\n      doToggle();\n    }\n    this._checkConfigured();\n    const siblingItemIsWaiting = !!this._timeoutId;\n    const hasPoints = this._points.length > 1;\n    if (hasPoints && !siblingItemIsWaiting) {\n      if (this._isMovingToSubmenu()) {\n        this._startTimeout(doToggle);\n      } else {\n        doToggle();\n      }\n    } else if (!siblingItemIsWaiting) {\n      doToggle();\n    }\n  }\n  /**\n   * Start the delayed toggle handler if one isn't running already.\n   *\n   * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n   * users mouse is on an item in the current menu.\n   *\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n  _startTimeout(doToggle) {\n    // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n    // Wait for some period of time before determining if the previous menu should close in\n    // cases where the user may have moved towards the submenu but stopped on a sibling menu\n    // item intentionally.\n    const timeoutId = setTimeout(() => {\n      // Resolve if the user is currently moused over some element in the root menu\n      if (this._pointerTracker.activeElement && timeoutId === this._timeoutId) {\n        doToggle();\n      }\n      this._timeoutId = null;\n    }, CLOSE_DELAY);\n    this._timeoutId = timeoutId;\n  }\n  /** Whether the user is heading towards the open submenu. */\n  _isMovingToSubmenu() {\n    const submenuPoints = this._getSubmenuBounds();\n    if (!submenuPoints) {\n      return false;\n    }\n    let numMoving = 0;\n    const currPoint = this._points[this._points.length - 1];\n    // start from the second last point and calculate the slope between each point and the last\n    // point.\n    for (let i = this._points.length - 2; i >= 0; i--) {\n      const previous = this._points[i];\n      const slope = getSlope(currPoint, previous);\n      if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n        numMoving++;\n      }\n    }\n    return numMoving >= Math.floor(NUM_POINTS / 2);\n  }\n  /** Get the bounding DOMRect for the open submenu. */\n  _getSubmenuBounds() {\n    return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n  }\n  /**\n   * Check if a reference to the PointerFocusTracker and menu element is provided.\n   * @throws an error if neither reference is provided.\n   */\n  _checkConfigured() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._pointerTracker) {\n        throwMissingPointerFocusTracker();\n      }\n      if (!this._menu) {\n        throwMissingMenuReference();\n      }\n    }\n  }\n  /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n  _subscribeToMouseMoves() {\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._menu.nativeElement, 'mousemove').pipe(filter((_, index) => index % MOUSE_MOVE_SAMPLE_FREQUENCY === 0), takeUntil(this._destroyed)).subscribe(event => {\n        this._points.push({\n          x: event.clientX,\n          y: event.clientY\n        });\n        if (this._points.length > NUM_POINTS) {\n          this._points.shift();\n        }\n      });\n    });\n  }\n  static {\n    this.ɵfac = function TargetMenuAim_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TargetMenuAim)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TargetMenuAim,\n      factory: TargetMenuAim.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TargetMenuAim, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\nclass CdkTargetMenuAim {\n  static {\n    this.ɵfac = function CdkTargetMenuAim_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTargetMenuAim)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTargetMenuAim,\n      selectors: [[\"\", \"cdkTargetMenuAim\", \"\"]],\n      exportAs: [\"cdkTargetMenuAim\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MENU_AIM,\n        useClass: TargetMenuAim\n      }])]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkTargetMenuAim, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTargetMenuAim]',\n      exportAs: 'cdkTargetMenuAim',\n      standalone: true,\n      providers: [{\n        provide: MENU_AIM,\n        useClass: TargetMenuAim\n      }]\n    }]\n  }], null, null);\n})();\n\n/** Checks whether a keyboard event will trigger a native `click` event on an element. */\nfunction eventDispatchesNativeClick(elementRef, event) {\n  // Synthetic events won't trigger clicks.\n  if (!event.isTrusted) {\n    return false;\n  }\n  const el = elementRef.nativeElement;\n  const keyCode = event.keyCode;\n  // Buttons trigger clicks both on space and enter events.\n  if (el.nodeName === 'BUTTON' && !el.disabled) {\n    return keyCode === ENTER || keyCode === SPACE;\n  }\n  // Links only trigger clicks on enter.\n  if (el.nodeName === 'A') {\n    return keyCode === ENTER;\n  }\n  // Any other elements won't dispatch clicks from keyboard events.\n  return false;\n}\n\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\nclass CdkMenuTrigger extends CdkMenuTriggerBase {\n  constructor() {\n    super();\n    this._elementRef = inject(ElementRef);\n    this._overlay = inject(Overlay);\n    this._ngZone = inject(NgZone);\n    this._changeDetectorRef = inject(ChangeDetectorRef);\n    this._inputModalityDetector = inject(InputModalityDetector);\n    this._directionality = inject(Directionality, {\n      optional: true\n    });\n    /** The parent menu this trigger belongs to. */\n    this._parentMenu = inject(CDK_MENU, {\n      optional: true\n    });\n    /** The menu aim service used by this menu. */\n    this._menuAim = inject(MENU_AIM, {\n      optional: true\n    });\n    this._setRole();\n    this._registerCloseHandler();\n    this._subscribeToMenuStackClosed();\n    this._subscribeToMouseEnter();\n    this._subscribeToMenuStackHasFocus();\n    this._setType();\n  }\n  /** Toggle the attached menu. */\n  toggle() {\n    this.isOpen() ? this.close() : this.open();\n  }\n  /** Open the attached menu. */\n  open() {\n    if (!this.isOpen() && this.menuTemplateRef != null) {\n      this.opened.next();\n      this.overlayRef = this.overlayRef || this._overlay.create(this._getOverlayConfig());\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._changeDetectorRef.markForCheck();\n      this._subscribeToOutsideClicks();\n    }\n  }\n  /** Close the opened menu. */\n  close() {\n    if (this.isOpen()) {\n      this.closed.next();\n      this.overlayRef.detach();\n      this._changeDetectorRef.markForCheck();\n    }\n    this._closeSiblingTriggers();\n  }\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n   */\n  getMenu() {\n    return this.childMenu;\n  }\n  /**\n   * Handles keyboard events for the menu item.\n   * @param event The keyboard event to handle\n   */\n  _toggleOnKeydown(event) {\n    const isParentVertical = this._parentMenu?.orientation === 'vertical';\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        // Skip events that will trigger clicks so the handler doesn't get triggered twice.\n        if (!hasModifierKey(event) && !eventDispatchesNativeClick(this._elementRef, event)) {\n          this.toggle();\n          this.childMenu?.focusFirstItem('keyboard');\n        }\n        break;\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n      case DOWN_ARROW:\n      case UP_ARROW:\n        if (!hasModifierKey(event)) {\n          if (!isParentVertical) {\n            event.preventDefault();\n            this.open();\n            event.keyCode === DOWN_ARROW ? this.childMenu?.focusFirstItem('keyboard') : this.childMenu?.focusLastItem('keyboard');\n          }\n        }\n        break;\n    }\n  }\n  /** Handles clicks on the menu trigger. */\n  _handleClick() {\n    this.toggle();\n    this.childMenu?.focusFirstItem('mouse');\n  }\n  /**\n   * Sets whether the trigger's menu stack has focus.\n   * @param hasFocus Whether the menu stack has focus.\n   */\n  _setHasFocus(hasFocus) {\n    if (!this._parentMenu) {\n      this.menuStack.setHasFocus(hasFocus);\n    }\n  }\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n  _subscribeToMouseEnter() {\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => {\n        return (\n          // Skip fake `mouseenter` events dispatched by touch devices.\n          this._inputModalityDetector.mostRecentModality !== 'touch' && !this.menuStack.isEmpty() && !this.isOpen()\n        );\n      }), takeUntil(this.destroyed)).subscribe(() => {\n        // Closes any sibling menu items and opens the menu associated with this trigger.\n        const toggleMenus = () => this._ngZone.run(() => {\n          this._closeSiblingTriggers();\n          this.open();\n        });\n        if (this._menuAim) {\n          this._menuAim.toggle(toggleMenus);\n        } else {\n          toggleMenus();\n        }\n      });\n    });\n  }\n  /** Close out any sibling menu trigger menus. */\n  _closeSiblingTriggers() {\n    if (this._parentMenu) {\n      // If nothing was removed from the stack and the last element is not the parent item\n      // that means that the parent menu is a menu bar since we don't put the menu bar on the\n      // stack\n      const isParentMenuBar = !this.menuStack.closeSubMenuOf(this._parentMenu) && this.menuStack.peek() !== this._parentMenu;\n      if (isParentMenuBar) {\n        this.menuStack.closeAll();\n      }\n    } else {\n      this.menuStack.closeAll();\n    }\n  }\n  /** Get the configuration object used to create the overlay. */\n  _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(),\n      scrollStrategy: this.menuScrollStrategy(),\n      direction: this._directionality || undefined\n    });\n  }\n  /** Build the position strategy for the overlay which specifies where to place the menu. */\n  _getOverlayPositionStrategy() {\n    return this._overlay.position().flexibleConnectedTo(this._elementRef).withLockedPosition().withGrowAfterOpen().withPositions(this._getOverlayPositions());\n  }\n  /** Get the preferred positions for the opened menu relative to the menu item. */\n  _getOverlayPositions() {\n    return this.menuPosition ?? (!this._parentMenu || this._parentMenu.orientation === 'horizontal' ? STANDARD_DROPDOWN_BELOW_POSITIONS : STANDARD_DROPDOWN_ADJACENT_POSITIONS);\n  }\n  /**\n   * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n   * this triggers when requested.\n   */\n  _registerCloseHandler() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n        item\n      }) => {\n        if (item === this.childMenu) {\n          this.close();\n        }\n      });\n    }\n  }\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   */\n  _subscribeToOutsideClicks() {\n    if (this.overlayRef) {\n      this.overlayRef.outsidePointerEvents().pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        const target = _getEventTarget(event);\n        const element = this._elementRef.nativeElement;\n        if (target !== element && !element.contains(target)) {\n          if (!this.isElementInsideMenuStack(target)) {\n            this.menuStack.closeAll();\n          } else {\n            this._closeSiblingTriggers();\n          }\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n  _subscribeToMenuStackHasFocus() {\n    if (!this._parentMenu) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        if (!hasFocus) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /** Subscribe to the MenuStack closed events. */\n  _subscribeToMenuStackClosed() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.subscribe(({\n        focusParentTrigger\n      }) => {\n        if (focusParentTrigger && !this.menuStack.length()) {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n  }\n  /** Sets the role attribute for this trigger if needed. */\n  _setRole() {\n    // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n    // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n    if (!this._parentMenu) {\n      this._elementRef.nativeElement.setAttribute('role', 'button');\n    }\n  }\n  /** Sets thte `type` attribute of the trigger. */\n  _setType() {\n    const element = this._elementRef.nativeElement;\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevents form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n  static {\n    this.ɵfac = function CdkMenuTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuTrigger)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuTrigger,\n      selectors: [[\"\", \"cdkMenuTriggerFor\", \"\"]],\n      hostAttrs: [1, \"cdk-menu-trigger\"],\n      hostVars: 2,\n      hostBindings: function CdkMenuTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focusin\", function CdkMenuTrigger_focusin_HostBindingHandler() {\n            return ctx._setHasFocus(true);\n          })(\"focusout\", function CdkMenuTrigger_focusout_HostBindingHandler() {\n            return ctx._setHasFocus(false);\n          })(\"keydown\", function CdkMenuTrigger_keydown_HostBindingHandler($event) {\n            return ctx._toggleOnKeydown($event);\n          })(\"click\", function CdkMenuTrigger_click_HostBindingHandler() {\n            return ctx._handleClick();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-haspopup\", ctx.menuTemplateRef ? \"menu\" : null)(\"aria-expanded\", ctx.menuTemplateRef == null ? null : ctx.isOpen());\n        }\n      },\n      inputs: {\n        menuTemplateRef: [0, \"cdkMenuTriggerFor\", \"menuTemplateRef\"],\n        menuPosition: [0, \"cdkMenuPosition\", \"menuPosition\"],\n        menuData: [0, \"cdkMenuTriggerData\", \"menuData\"]\n      },\n      outputs: {\n        opened: \"cdkMenuOpened\",\n        closed: \"cdkMenuClosed\"\n      },\n      exportAs: [\"cdkMenuTriggerFor\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MENU_TRIGGER,\n        useExisting: CdkMenuTrigger\n      }, PARENT_OR_NEW_MENU_STACK_PROVIDER]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuTriggerFor]',\n      exportAs: 'cdkMenuTriggerFor',\n      standalone: true,\n      host: {\n        'class': 'cdk-menu-trigger',\n        '[attr.aria-haspopup]': 'menuTemplateRef ? \"menu\" : null',\n        '[attr.aria-expanded]': 'menuTemplateRef == null ? null : isOpen()',\n        '(focusin)': '_setHasFocus(true)',\n        '(focusout)': '_setHasFocus(false)',\n        '(keydown)': '_toggleOnKeydown($event)',\n        '(click)': '_handleClick()'\n      },\n      inputs: [{\n        name: 'menuTemplateRef',\n        alias: 'cdkMenuTriggerFor'\n      }, {\n        name: 'menuPosition',\n        alias: 'cdkMenuPosition'\n      }, {\n        name: 'menuData',\n        alias: 'cdkMenuTriggerData'\n      }],\n      outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkMenuTrigger\n      }, PARENT_OR_NEW_MENU_STACK_PROVIDER]\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\nclass CdkMenuItem {\n  /** Whether the menu item opens a menu. */\n  get hasMenu() {\n    return this._menuTrigger?.menuTemplateRef != null;\n  }\n  constructor() {\n    this._dir = inject(Directionality, {\n      optional: true\n    });\n    this._elementRef = inject(ElementRef);\n    this._ngZone = inject(NgZone);\n    this._inputModalityDetector = inject(InputModalityDetector);\n    /** The menu aim service used by this menu. */\n    this._menuAim = inject(MENU_AIM, {\n      optional: true\n    });\n    /** The stack of menus this menu belongs to. */\n    this._menuStack = inject(MENU_STACK);\n    /** The parent menu in which this menuitem resides. */\n    this._parentMenu = inject(CDK_MENU, {\n      optional: true\n    });\n    /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n    this._menuTrigger = inject(CdkMenuTrigger, {\n      optional: true,\n      self: true\n    });\n    /**  Whether the CdkMenuItem is disabled - defaults to false */\n    this.disabled = false;\n    /**\n     * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n     * event.\n     */\n    this.triggered = new EventEmitter();\n    /**\n     * The tabindex for this menu item managed internally and used for implementing roving a\n     * tab index.\n     */\n    this._tabindex = -1;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    this.closeOnSpacebarTrigger = true;\n    /** Emits when the menu item is destroyed. */\n    this.destroyed = new Subject();\n    this._setupMouseEnter();\n    this._setType();\n    if (this._isStandaloneItem()) {\n      this._tabindex = 0;\n    }\n  }\n  ngOnDestroy() {\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n  /** Place focus on the element. */\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n  /**\n   * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n   * on the cdkMenuItemTriggered emitter and close all open menus.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  trigger(options) {\n    const {\n      keepOpen\n    } = {\n      ...options\n    };\n    if (!this.disabled && !this.hasMenu) {\n      this.triggered.next();\n      if (!keepOpen) {\n        this._menuStack.closeAll({\n          focusParentTrigger: true\n        });\n      }\n    }\n  }\n  /** Return true if this MenuItem has an attached menu and it is open. */\n  isMenuOpen() {\n    return !!this._menuTrigger?.isOpen();\n  }\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n   * @return the menu if it is open, otherwise undefined.\n   */\n  getMenu() {\n    return this._menuTrigger?.getMenu();\n  }\n  /** Get the CdkMenuTrigger associated with this element. */\n  getMenuTrigger() {\n    return this._menuTrigger;\n  }\n  /** Get the label for this element which is required by the FocusableOption interface. */\n  getLabel() {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n  /** Reset the tabindex to -1. */\n  _resetTabIndex() {\n    if (!this._isStandaloneItem()) {\n      this._tabindex = -1;\n    }\n  }\n  /**\n   * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n   * is not in a menu bar.\n   */\n  _setTabIndex(event) {\n    if (this.disabled) {\n      return;\n    }\n    // don't set the tabindex if there are no open sibling or parent menus\n    if (!event || !this._menuStack.isEmpty()) {\n      this._tabindex = 0;\n    }\n  }\n  /**\n   * Handles keyboard events for the menu item, specifically either triggering the user defined\n   * callback or opening/closing the current menu based on whether the left or right arrow key was\n   * pressed.\n   * @param event the keyboard event to handle\n   */\n  _onKeydown(event) {\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        // Skip events that will trigger clicks so the handler doesn't get triggered twice.\n        if (!hasModifierKey(event) && !eventDispatchesNativeClick(this._elementRef, event)) {\n          this.trigger({\n            keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger\n          });\n        }\n        break;\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._forwardArrowPressed(event);\n            } else {\n              this._backArrowPressed(event);\n            }\n          }\n        }\n        break;\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._backArrowPressed(event);\n            } else {\n              this._forwardArrowPressed(event);\n            }\n          }\n        }\n        break;\n    }\n  }\n  /** Whether this menu item is standalone or within a menu or menu bar. */\n  _isStandaloneItem() {\n    return !this._parentMenu;\n  }\n  /**\n   * Handles the user pressing the back arrow key.\n   * @param event The keyboard event.\n   */\n  _backArrowPressed(event) {\n    const parentMenu = this._parentMenu;\n    if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n      event.preventDefault();\n      this._menuStack.close(parentMenu, {\n        focusNextOnEmpty: this._menuStack.inlineMenuOrientation() === 'horizontal' ? FocusNext.previousItem : FocusNext.currentItem,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\n   * Handles the user pressing the forward arrow key.\n   * @param event The keyboard event.\n   */\n  _forwardArrowPressed(event) {\n    if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n      event.preventDefault();\n      this._menuStack.closeAll({\n        focusNextOnEmpty: FocusNext.nextItem,\n        focusParentTrigger: true\n      });\n    }\n  }\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n  _setupMouseEnter() {\n    if (!this._isStandaloneItem()) {\n      const closeOpenSiblings = () => this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu));\n      this._ngZone.runOutsideAngular(() => fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(filter(() => {\n        return (\n          // Skip fake `mouseenter` events dispatched by touch devices.\n          this._inputModalityDetector.mostRecentModality !== 'touch' && !this._menuStack.isEmpty() && !this.hasMenu\n        );\n      }), takeUntil(this.destroyed)).subscribe(() => {\n        if (this._menuAim) {\n          this._menuAim.toggle(closeOpenSiblings);\n        } else {\n          closeOpenSiblings();\n        }\n      }));\n    }\n  }\n  /**\n   * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n   * otherwise or if no parent.\n   */\n  _isParentVertical() {\n    return this._parentMenu?.orientation === 'vertical';\n  }\n  /** Sets the `type` attribute of the menu item. */\n  _setType() {\n    const element = this._elementRef.nativeElement;\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevent form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n  static {\n    this.ɵfac = function CdkMenuItem_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuItem)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuItem,\n      selectors: [[\"\", \"cdkMenuItem\", \"\"]],\n      hostAttrs: [\"role\", \"menuitem\", 1, \"cdk-menu-item\"],\n      hostVars: 2,\n      hostBindings: function CdkMenuItem_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"blur\", function CdkMenuItem_blur_HostBindingHandler() {\n            return ctx._resetTabIndex();\n          })(\"focus\", function CdkMenuItem_focus_HostBindingHandler() {\n            return ctx._setTabIndex();\n          })(\"click\", function CdkMenuItem_click_HostBindingHandler() {\n            return ctx.trigger();\n          })(\"keydown\", function CdkMenuItem_keydown_HostBindingHandler($event) {\n            return ctx._onKeydown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._tabindex);\n          i0.ɵɵattribute(\"aria-disabled\", ctx.disabled || null);\n        }\n      },\n      inputs: {\n        disabled: [2, \"cdkMenuItemDisabled\", \"disabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkMenuitemTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        triggered: \"cdkMenuItemTriggered\"\n      },\n      exportAs: [\"cdkMenuItem\"],\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItem, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItem]',\n      exportAs: 'cdkMenuItem',\n      standalone: true,\n      host: {\n        'role': 'menuitem',\n        'class': 'cdk-menu-item',\n        '[tabindex]': '_tabindex',\n        '[attr.aria-disabled]': 'disabled || null',\n        '(blur)': '_resetTabIndex()',\n        '(focus)': '_setTabIndex()',\n        '(click)': 'trigger()',\n        '(keydown)': '_onKeydown($event)'\n      }\n    }]\n  }], () => [], {\n    disabled: [{\n      type: Input,\n      args: [{\n        alias: 'cdkMenuItemDisabled',\n        transform: booleanAttribute\n      }]\n    }],\n    typeaheadLabel: [{\n      type: Input,\n      args: ['cdkMenuitemTypeaheadLabel']\n    }],\n    triggered: [{\n      type: Output,\n      args: ['cdkMenuItemTriggered']\n    }]\n  });\n})();\n\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\nclass PointerFocusTracker {\n  constructor( /** The list of items being tracked. */\n  _items) {\n    this._items = _items;\n    /** Emits when an element is moused into. */\n    this.entered = this._getItemPointerEntries();\n    /** Emits when an element is moused out. */\n    this.exited = this._getItemPointerExits();\n    /** Emits when this is destroyed. */\n    this._destroyed = new Subject();\n    this.entered.subscribe(element => this.activeElement = element);\n    this.exited.subscribe(() => {\n      this.previousElement = this.activeElement;\n      this.activeElement = undefined;\n    });\n  }\n  /** Stop the managers listeners. */\n  destroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\n   * Gets a stream of pointer (mouse) entries into the given items.\n   * This should typically run outside the Angular zone.\n   */\n  _getItemPointerEntries() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseenter').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n  /**\n   * Gets a stream of pointer (mouse) exits out of the given items.\n   * This should typically run outside the Angular zone.\n   */\n  _getItemPointerExits() {\n    return defer(() => this._items.changes.pipe(startWith(this._items), mergeMap(list => list.map(element => fromEvent(element._elementRef.nativeElement, 'mouseout').pipe(mapTo(element), takeUntil(this._items.changes)))), mergeAll()));\n  }\n}\n\n/** Counter used to create unique IDs for menus. */\nlet nextId$1 = 0;\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\nclass CdkMenuBase extends CdkMenuGroup {\n  constructor() {\n    super(...arguments);\n    /** The menu's native DOM host element. */\n    this.nativeElement = inject(ElementRef).nativeElement;\n    /** The Angular zone. */\n    this.ngZone = inject(NgZone);\n    /** The stack of menus this menu belongs to. */\n    this.menuStack = inject(MENU_STACK);\n    /** The menu aim service used by this menu. */\n    this.menuAim = inject(MENU_AIM, {\n      optional: true,\n      self: true\n    });\n    /** The directionality (text direction) of the current page. */\n    this.dir = inject(Directionality, {\n      optional: true\n    });\n    /** The id of the menu's host element. */\n    this.id = `cdk-menu-${nextId$1++}`;\n    /** The direction items in the menu flow. */\n    this.orientation = 'vertical';\n    /**\n     * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n     * user triggers with a trigger element).\n     */\n    this.isInline = false;\n    /** Emits when the MenuBar is destroyed. */\n    this.destroyed = new Subject();\n    /** Whether this menu's menu stack has focus. */\n    this._menuStackHasFocus = signal(false);\n    this._tabIndexSignal = computed(() => {\n      const tabindexIfInline = this._menuStackHasFocus() ? -1 : 0;\n      return this.isInline ? tabindexIfInline : null;\n    });\n  }\n  ngAfterContentInit() {\n    if (!this.isInline) {\n      this.menuStack.push(this);\n    }\n    this._setKeyManager();\n    this._subscribeToMenuStackHasFocus();\n    this._subscribeToMenuOpen();\n    this._subscribeToMenuStackClosed();\n    this._setUpPointerTracker();\n  }\n  ngOnDestroy() {\n    this.keyManager?.destroy();\n    this.destroyed.next();\n    this.destroyed.complete();\n    this.pointerTracker?.destroy();\n  }\n  /**\n   * Place focus on the first MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n  focusFirstItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setFirstItemActive();\n  }\n  /**\n   * Place focus on the last MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n  focusLastItem(focusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setLastItemActive();\n  }\n  /** Gets the tabindex for this menu. */\n  _getTabIndex() {\n    return this._tabIndexSignal();\n  }\n  /**\n   * Close the open menu if the current active item opened the requested MenuStackItem.\n   * @param menu The menu requested to be closed.\n   * @param options Options to configure the behavior on close.\n   *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n   */\n  closeOpenMenu(menu, options) {\n    const {\n      focusParentTrigger\n    } = {\n      ...options\n    };\n    const keyManager = this.keyManager;\n    const trigger = this.triggerItem;\n    if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n      trigger?.getMenuTrigger()?.close();\n      // If the user has moused over a sibling item we want to focus the element under mouse focus\n      // not the trigger which previously opened the now closed menu.\n      if (focusParentTrigger) {\n        if (trigger) {\n          keyManager.setActiveItem(trigger);\n        } else {\n          keyManager.setFirstItemActive();\n        }\n      }\n    }\n  }\n  /** Setup the FocusKeyManager with the correct orientation for the menu. */\n  _setKeyManager() {\n    this.keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead().withHomeAndEnd();\n    if (this.orientation === 'horizontal') {\n      this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n    } else {\n      this.keyManager.withVerticalOrientation();\n    }\n  }\n  /**\n   * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n   * and stop tracking it when the menu is closed.\n   */\n  _subscribeToMenuOpen() {\n    const exitCondition = merge(this.items.changes, this.destroyed);\n    this.items.changes.pipe(startWith(this.items), mergeMap(list => list.filter(item => item.hasMenu).map(item => item.getMenuTrigger().opened.pipe(mapTo(item), takeUntil(exitCondition)))), mergeAll(), switchMap(item => {\n      this.triggerItem = item;\n      return item.getMenuTrigger().closed;\n    }), takeUntil(this.destroyed)).subscribe(() => this.triggerItem = undefined);\n  }\n  /** Subscribe to the MenuStack close events. */\n  _subscribeToMenuStackClosed() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item,\n      focusParentTrigger\n    }) => this.closeOpenMenu(item, {\n      focusParentTrigger\n    }));\n  }\n  /** Subscribe to the MenuStack hasFocus events. */\n  _subscribeToMenuStackHasFocus() {\n    if (this.isInline) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        this._menuStackHasFocus.set(hasFocus);\n      });\n    }\n  }\n  /**\n   * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n   * with the latest menu item under mouse focus.\n   */\n  _setUpPointerTracker() {\n    if (this.menuAim) {\n      this.ngZone.runOutsideAngular(() => {\n        this.pointerTracker = new PointerFocusTracker(this.items);\n      });\n      this.menuAim.initialize(this, this.pointerTracker);\n    }\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCdkMenuBase_BaseFactory;\n      return function CdkMenuBase_Factory(__ngFactoryType__) {\n        return (ɵCdkMenuBase_BaseFactory || (ɵCdkMenuBase_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBase)))(__ngFactoryType__ || CdkMenuBase);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuBase,\n      contentQueries: function CdkMenuBase_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, CdkMenuItem, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n        }\n      },\n      hostAttrs: [\"role\", \"menu\"],\n      hostVars: 4,\n      hostBindings: function CdkMenuBase_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focus\", function CdkMenuBase_focus_HostBindingHandler() {\n            return ctx.focusFirstItem();\n          })(\"focusin\", function CdkMenuBase_focusin_HostBindingHandler() {\n            return ctx.menuStack.setHasFocus(true);\n          })(\"focusout\", function CdkMenuBase_focusout_HostBindingHandler() {\n            return ctx.menuStack.setHasFocus(false);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx._getTabIndex())(\"id\", ctx.id);\n          i0.ɵɵattribute(\"aria-orientation\", ctx.orientation)(\"data-cdk-menu-stack-id\", ctx.menuStack.id);\n        }\n      },\n      inputs: {\n        id: \"id\"\n      },\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBase, [{\n    type: Directive,\n    args: [{\n      host: {\n        'role': 'menu',\n        'class': '',\n        // reset the css class added by the super-class\n        '[tabindex]': '_getTabIndex()',\n        '[id]': 'id',\n        '[attr.aria-orientation]': 'orientation',\n        '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n        '(focus)': 'focusFirstItem()',\n        '(focusin)': 'menuStack.setHasFocus(true)',\n        '(focusout)': 'menuStack.setHasFocus(false)'\n      },\n      standalone: true\n    }]\n  }], null, {\n    id: [{\n      type: Input\n    }],\n    items: [{\n      type: ContentChildren,\n      args: [CdkMenuItem, {\n        descendants: true\n      }]\n    }]\n  });\n})();\n\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\nclass CdkMenu extends CdkMenuBase {\n  constructor() {\n    super();\n    this._parentTrigger = inject(MENU_TRIGGER, {\n      optional: true\n    });\n    /** Event emitted when the menu is closed. */\n    this.closed = new EventEmitter();\n    /** The direction items in the menu flow. */\n    this.orientation = 'vertical';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    this.isInline = !this._parentTrigger;\n    this.destroyed.subscribe(this.closed);\n    this._parentTrigger?.registerChildMenu(this);\n  }\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this.closed.complete();\n  }\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.onKeydown(event);\n        }\n        break;\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.menuStack.close(this, {\n            focusNextOnEmpty: FocusNext.currentItem,\n            focusParentTrigger: true\n          });\n        }\n        break;\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          this.menuStack.closeAll({\n            focusParentTrigger: true\n          });\n        }\n        break;\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Set focus the either the current, previous or next item based on the FocusNext event.\n   * @param focusNext The element to focus.\n   */\n  _toggleMenuFocus(focusNext) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case FocusNext.nextItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        break;\n      case FocusNext.previousItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        break;\n      case FocusNext.currentItem:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n  _subscribeToMenuStackEmptied() {\n    this.menuStack.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleMenuFocus(event));\n  }\n  static {\n    this.ɵfac = function CdkMenu_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenu)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenu,\n      selectors: [[\"\", \"cdkMenu\", \"\"]],\n      hostAttrs: [\"role\", \"menu\", 1, \"cdk-menu\"],\n      hostVars: 2,\n      hostBindings: function CdkMenu_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkMenu_keydown_HostBindingHandler($event) {\n            return ctx._handleKeyEvent($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"cdk-menu-inline\", ctx.isInline);\n        }\n      },\n      outputs: {\n        closed: \"closed\"\n      },\n      exportAs: [\"cdkMenu\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenu\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenu\n      }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenu, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenu]',\n      exportAs: 'cdkMenu',\n      standalone: true,\n      host: {\n        'role': 'menu',\n        'class': 'cdk-menu',\n        '[class.cdk-menu-inline]': 'isInline',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenu\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenu\n      }, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical')]\n    }]\n  }], () => [], {\n    closed: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\nclass CdkMenuBar extends CdkMenuBase {\n  constructor() {\n    super(...arguments);\n    /** The direction items in the menu flow. */\n    this.orientation = 'horizontal';\n    /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n    this.isInline = true;\n  }\n  ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n  _handleKeyEvent(event) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case UP_ARROW:\n      case DOWN_ARROW:\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW;\n          // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n          // up/down keys were clicked: if the current menu is open, close it then focus and open the\n          // next  menu.\n          if (horizontalArrows) {\n            event.preventDefault();\n            const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n            keyManager.activeItem?.getMenuTrigger()?.close();\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.onKeydown(event);\n            if (prevIsOpen) {\n              keyManager.activeItem?.getMenuTrigger()?.open();\n            }\n          }\n        }\n        break;\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Set focus to either the current, previous or next item based on the FocusNext event, then\n   * open the previous or next item.\n   * @param focusNext The element to focus.\n   */\n  _toggleOpenMenu(focusNext) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case FocusNext.nextItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n      case FocusNext.previousItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n      case FocusNext.currentItem:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n  /** Subscribe to the MenuStack emptied events. */\n  _subscribeToMenuStackEmptied() {\n    this.menuStack?.emptied.pipe(takeUntil(this.destroyed)).subscribe(event => this._toggleOpenMenu(event));\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCdkMenuBar_BaseFactory;\n      return function CdkMenuBar_Factory(__ngFactoryType__) {\n        return (ɵCdkMenuBar_BaseFactory || (ɵCdkMenuBar_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuBar)))(__ngFactoryType__ || CdkMenuBar);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuBar,\n      selectors: [[\"\", \"cdkMenuBar\", \"\"]],\n      hostAttrs: [\"role\", \"menubar\", 1, \"cdk-menu-bar\"],\n      hostBindings: function CdkMenuBar_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function CdkMenuBar_keydown_HostBindingHandler($event) {\n            return ctx._handleKeyEvent($event);\n          });\n        }\n      },\n      exportAs: [\"cdkMenuBar\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenuBar\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenuBar\n      }, {\n        provide: MENU_STACK,\n        useFactory: () => MenuStack.inline('horizontal')\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuBar, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuBar]',\n      exportAs: 'cdkMenuBar',\n      standalone: true,\n      host: {\n        'role': 'menubar',\n        'class': 'cdk-menu-bar',\n        '(keydown)': '_handleKeyEvent($event)'\n      },\n      providers: [{\n        provide: CdkMenuGroup,\n        useExisting: CdkMenuBar\n      }, {\n        provide: CDK_MENU,\n        useExisting: CdkMenuBar\n      }, {\n        provide: MENU_STACK,\n        useFactory: () => MenuStack.inline('horizontal')\n      }]\n    }]\n  }], null, null);\n})();\n\n/** Base class providing checked state for selectable MenuItems. */\nclass CdkMenuItemSelectable extends CdkMenuItem {\n  constructor() {\n    super(...arguments);\n    /** Whether the element is checked */\n    this.checked = false;\n    /** Whether the item should close the menu if triggered by the spacebar. */\n    this.closeOnSpacebarTrigger = false;\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCdkMenuItemSelectable_BaseFactory;\n      return function CdkMenuItemSelectable_Factory(__ngFactoryType__) {\n        return (ɵCdkMenuItemSelectable_BaseFactory || (ɵCdkMenuItemSelectable_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemSelectable)))(__ngFactoryType__ || CdkMenuItemSelectable);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuItemSelectable,\n      hostVars: 2,\n      hostBindings: function CdkMenuItemSelectable_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-checked\", !!ctx.checked)(\"aria-disabled\", ctx.disabled || null);\n        }\n      },\n      inputs: {\n        checked: [2, \"cdkMenuItemChecked\", \"checked\", booleanAttribute]\n      },\n      standalone: true,\n      features: [i0.ɵɵInputTransformsFeature, i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemSelectable, [{\n    type: Directive,\n    args: [{\n      host: {\n        '[attr.aria-checked]': '!!checked',\n        '[attr.aria-disabled]': 'disabled || null'\n      },\n      standalone: true\n    }]\n  }], null, {\n    checked: [{\n      type: Input,\n      args: [{\n        alias: 'cdkMenuItemChecked',\n        transform: booleanAttribute\n      }]\n    }]\n  });\n})();\n\n/** Counter used to set a unique id and name for a selectable item */\nlet nextId = 0;\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\nclass CdkMenuItemRadio extends CdkMenuItemSelectable {\n  constructor() {\n    super();\n    /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n    this._selectionDispatcher = inject(UniqueSelectionDispatcher);\n    /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n    this._id = `${nextId++}`;\n    this._registerDispatcherListener();\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this._removeDispatcherListener();\n  }\n  /**\n   * Toggles the checked state of the radio-button.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  trigger(options) {\n    super.trigger(options);\n    if (!this.disabled) {\n      this._selectionDispatcher.notify(this._id, '');\n    }\n  }\n  /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n  _registerDispatcherListener() {\n    this._removeDispatcherListener = this._selectionDispatcher.listen(id => {\n      this.checked = this._id === id;\n    });\n  }\n  static {\n    this.ɵfac = function CdkMenuItemRadio_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuItemRadio)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuItemRadio,\n      selectors: [[\"\", \"cdkMenuItemRadio\", \"\"]],\n      hostAttrs: [\"role\", \"menuitemradio\"],\n      hostVars: 2,\n      hostBindings: function CdkMenuItemRadio_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"cdk-menu-item-radio\", true);\n        }\n      },\n      exportAs: [\"cdkMenuItemRadio\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemRadio\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemRadio, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemRadio]',\n      exportAs: 'cdkMenuItemRadio',\n      standalone: true,\n      host: {\n        'role': 'menuitemradio',\n        '[class.cdk-menu-item-radio]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemRadio\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], () => [], null);\n})();\n\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\nclass CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n  /**\n   * Toggle the checked state of the checkbox.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  trigger(options) {\n    super.trigger(options);\n    if (!this.disabled) {\n      this.checked = !this.checked;\n    }\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCdkMenuItemCheckbox_BaseFactory;\n      return function CdkMenuItemCheckbox_Factory(__ngFactoryType__) {\n        return (ɵCdkMenuItemCheckbox_BaseFactory || (ɵCdkMenuItemCheckbox_BaseFactory = i0.ɵɵgetInheritedFactory(CdkMenuItemCheckbox)))(__ngFactoryType__ || CdkMenuItemCheckbox);\n      };\n    })();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkMenuItemCheckbox,\n      selectors: [[\"\", \"cdkMenuItemCheckbox\", \"\"]],\n      hostAttrs: [\"role\", \"menuitemcheckbox\"],\n      hostVars: 2,\n      hostBindings: function CdkMenuItemCheckbox_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"cdk-menu-item-checkbox\", true);\n        }\n      },\n      exportAs: [\"cdkMenuItemCheckbox\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemCheckbox\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuItemCheckbox, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkMenuItemCheckbox]',\n      exportAs: 'cdkMenuItemCheckbox',\n      standalone: true,\n      host: {\n        'role': 'menuitemcheckbox',\n        '[class.cdk-menu-item-checkbox]': 'true'\n      },\n      providers: [{\n        provide: CdkMenuItemSelectable,\n        useExisting: CdkMenuItemCheckbox\n      }, {\n        provide: CdkMenuItem,\n        useExisting: CdkMenuItemSelectable\n      }]\n    }]\n  }], null, null);\n})();\n\n/** The preferred menu positions for the context menu. */\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n  // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n  // hover event. We offset the context menu 2px by default to prevent this from occurring.\n  const offsetX = position.overlayX === 'start' ? 2 : -2;\n  const offsetY = position.overlayY === 'top' ? 2 : -2;\n  return {\n    ...position,\n    offsetX,\n    offsetY\n  };\n});\n/** Tracks the last open context menu trigger across the entire application. */\nclass ContextMenuTracker {\n  /**\n   * Close the previous open context menu and set the given one as being open.\n   * @param trigger The trigger for the currently open Context Menu.\n   */\n  update(trigger) {\n    if (ContextMenuTracker._openContextMenuTrigger !== trigger) {\n      ContextMenuTracker._openContextMenuTrigger?.close();\n      ContextMenuTracker._openContextMenuTrigger = trigger;\n    }\n  }\n  static {\n    this.ɵfac = function ContextMenuTracker_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ContextMenuTracker)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ContextMenuTracker,\n      factory: ContextMenuTracker.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ContextMenuTracker, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\nclass CdkContextMenuTrigger extends CdkMenuTriggerBase {\n  constructor() {\n    super();\n    /** The CDK overlay service. */\n    this._overlay = inject(Overlay);\n    /** The directionality of the page. */\n    this._directionality = inject(Directionality, {\n      optional: true\n    });\n    /** The app's context menu tracking registry */\n    this._contextMenuTracker = inject(ContextMenuTracker);\n    this._changeDetectorRef = inject(ChangeDetectorRef);\n    /** Whether the context menu is disabled. */\n    this.disabled = false;\n    this._setMenuStackCloseListener();\n  }\n  /**\n   * Open the attached menu at the specified location.\n   * @param coordinates where to open the context menu\n   */\n  open(coordinates) {\n    this._open(null, coordinates);\n    this._changeDetectorRef.markForCheck();\n  }\n  /** Close the currently opened context menu. */\n  close() {\n    this.menuStack.closeAll();\n  }\n  /**\n   * Open the context menu and closes any previously open menus.\n   * @param event the mouse event which opens the context menu.\n   */\n  _openOnContextMenu(event) {\n    if (!this.disabled) {\n      // Prevent the native context menu from opening because we're opening a custom one.\n      event.preventDefault();\n      // Stop event propagation to ensure that only the closest enabled context menu opens.\n      // Otherwise, any context menus attached to containing elements would *also* open,\n      // resulting in multiple stacked context menus being displayed.\n      event.stopPropagation();\n      this._contextMenuTracker.update(this);\n      this._open(event, {\n        x: event.clientX,\n        y: event.clientY\n      });\n      // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n      if (event.button === 2) {\n        this.childMenu?.focusFirstItem('mouse');\n      } else if (event.button === 0) {\n        this.childMenu?.focusFirstItem('keyboard');\n      } else {\n        this.childMenu?.focusFirstItem('program');\n      }\n    }\n  }\n  /**\n   * Get the configuration object used to create the overlay.\n   * @param coordinates the location to place the opened menu\n   */\n  _getOverlayConfig(coordinates) {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(coordinates),\n      scrollStrategy: this.menuScrollStrategy(),\n      direction: this._directionality || undefined\n    });\n  }\n  /**\n   * Get the position strategy for the overlay which specifies where to place the menu.\n   * @param coordinates the location to place the opened menu\n   */\n  _getOverlayPositionStrategy(coordinates) {\n    return this._overlay.position().flexibleConnectedTo(coordinates).withLockedPosition().withGrowAfterOpen().withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n  }\n  /** Subscribe to the menu stack close events and close this menu when requested. */\n  _setMenuStackCloseListener() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({\n      item\n    }) => {\n      if (item === this.childMenu && this.isOpen()) {\n        this.closed.next();\n        this.overlayRef.detach();\n      }\n    });\n  }\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   * @param userEvent User-generated event that opened the menu.\n   */\n  _subscribeToOutsideClicks(userEvent) {\n    if (this.overlayRef) {\n      let outsideClicks = this.overlayRef.outsidePointerEvents();\n      if (userEvent) {\n        const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({\n          type\n        }) => type === 'auxclick');\n        outsideClicks = merge(\n        // Using a mouse, the `contextmenu` event can fire either when pressing the right button\n        // or left button + control. Most browsers won't dispatch a `click` event right after\n        // a `contextmenu` event triggered by left button + control, but Safari will (see #27832).\n        // This closes the menu immediately. To work around it, we check that both the triggering\n        // event and the current outside click event both had the control key pressed, and that\n        // that this is the first outside click event.\n        nonAuxClicks.pipe(skipWhile((event, index) => userEvent.ctrlKey && index === 0 && event.ctrlKey)),\n        // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n        // because it fires when the mouse is released on the same click that opened the menu.\n        auxClicks.pipe(skip(1)));\n      }\n      outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        if (!this.isElementInsideMenuStack(_getEventTarget(event))) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n  /**\n   * Open the attached menu at the specified location.\n   * @param userEvent User-generated event that opened the menu\n   * @param coordinates where to open the context menu\n   */\n  _open(userEvent, coordinates) {\n    if (this.disabled) {\n      return;\n    }\n    if (this.isOpen()) {\n      // since we're moving this menu we need to close any submenus first otherwise they end up\n      // disconnected from this one.\n      this.menuStack.closeSubMenuOf(this.childMenu);\n      this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n      this.overlayRef.updatePosition();\n    } else {\n      this.opened.next();\n      if (this.overlayRef) {\n        this.overlayRef.getConfig().positionStrategy.setOrigin(coordinates);\n        this.overlayRef.updatePosition();\n      } else {\n        this.overlayRef = this._overlay.create(this._getOverlayConfig(coordinates));\n      }\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._subscribeToOutsideClicks(userEvent);\n    }\n  }\n  static {\n    this.ɵfac = function CdkContextMenuTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkContextMenuTrigger)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkContextMenuTrigger,\n      selectors: [[\"\", \"cdkContextMenuTriggerFor\", \"\"]],\n      hostVars: 1,\n      hostBindings: function CdkContextMenuTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"contextmenu\", function CdkContextMenuTrigger_contextmenu_HostBindingHandler($event) {\n            return ctx._openOnContextMenu($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"data-cdk-menu-stack-id\", null);\n        }\n      },\n      inputs: {\n        menuTemplateRef: [0, \"cdkContextMenuTriggerFor\", \"menuTemplateRef\"],\n        menuPosition: [0, \"cdkContextMenuPosition\", \"menuPosition\"],\n        menuData: [0, \"cdkContextMenuTriggerData\", \"menuData\"],\n        disabled: [2, \"cdkContextMenuDisabled\", \"disabled\", booleanAttribute]\n      },\n      outputs: {\n        opened: \"cdkContextMenuOpened\",\n        closed: \"cdkContextMenuClosed\"\n      },\n      exportAs: [\"cdkContextMenuTriggerFor\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MENU_TRIGGER,\n        useExisting: CdkContextMenuTrigger\n      }, {\n        provide: MENU_STACK,\n        useClass: MenuStack\n      }]), i0.ɵɵInputTransformsFeature, i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkContextMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkContextMenuTriggerFor]',\n      exportAs: 'cdkContextMenuTriggerFor',\n      standalone: true,\n      host: {\n        '[attr.data-cdk-menu-stack-id]': 'null',\n        '(contextmenu)': '_openOnContextMenu($event)'\n      },\n      inputs: [{\n        name: 'menuTemplateRef',\n        alias: 'cdkContextMenuTriggerFor'\n      }, {\n        name: 'menuPosition',\n        alias: 'cdkContextMenuPosition'\n      }, {\n        name: 'menuData',\n        alias: 'cdkContextMenuTriggerData'\n      }],\n      outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\n      providers: [{\n        provide: MENU_TRIGGER,\n        useExisting: CdkContextMenuTrigger\n      }, {\n        provide: MENU_STACK,\n        useClass: MenuStack\n      }]\n    }]\n  }], () => [], {\n    disabled: [{\n      type: Input,\n      args: [{\n        alias: 'cdkContextMenuDisabled',\n        transform: booleanAttribute\n      }]\n    }]\n  });\n})();\nconst MENU_DIRECTIVES = [CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim];\n/** Module that declares components and directives for the CDK menu. */\nclass CdkMenuModule {\n  static {\n    this.ɵfac = function CdkMenuModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkMenuModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CdkMenuModule,\n      imports: [OverlayModule, CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim],\n      exports: [CdkMenuBar, CdkMenu, CdkMenuItem, CdkMenuItemRadio, CdkMenuItemCheckbox, CdkMenuTrigger, CdkMenuGroup, CdkContextMenuTrigger, CdkTargetMenuAim]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [OverlayModule]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CdkMenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [OverlayModule, ...MENU_DIRECTIVES],\n      exports: MENU_DIRECTIVES\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_MENU, CdkContextMenuTrigger, CdkMenu, CdkMenuBar, CdkMenuBase, CdkMenuGroup, CdkMenuItem, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItemSelectable, CdkMenuModule, CdkMenuTrigger, CdkMenuTriggerBase, CdkTargetMenuAim, ContextMenuTracker, FocusNext, MENU_AIM, MENU_SCROLL_STRATEGY, MENU_STACK, MENU_TRIGGER, MenuStack, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER, PARENT_OR_NEW_MENU_STACK_PROVIDER, PointerFocusTracker, TargetMenuAim };\n"],
  "mappings": "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",
  "names": ["FocusNext"]
}
